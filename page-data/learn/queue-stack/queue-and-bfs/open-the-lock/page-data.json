{"componentChunkName":"component---src-templates-blog-post-tsx","path":"/learn/queue-stack/queue-and-bfs/open-the-lock/","result":{"data":{"site":{"siteMetadata":{"title":"Gatsby Default Starter","author":"@gatsbyjs"}},"markdownRemark":{"id":"eda76740-aa47-5b67-8a44-e5ee424ffaeb","html":"<h2>Open the Lock</h2>\n<h3>Question：</h3>\n<p>\nYou have a lock in front of you with 4 circular wheels.  Each wheel has 10 slots: <code>'0', '1', '2', '3', '4', '5', '6', '7', '8', '9'</code>.  The wheels can rotate freely and wrap around: for example we can turn <code>'9'</code> to be <code>'0'</code>, or <code>'0'</code> to be <code>'9'</code>.  Each move consists of turning one wheel one slot.\n</p><p>\nThe lock initially starts at <code>'0000'</code>, a string representing the state of the 4 wheels.\n</p><p>\nYou are given a list of <code>deadends</code> dead ends, meaning if the lock displays any of these codes, the wheels of the lock will stop turning and you will be unable to open it.\n</p><p>\nGiven a <code>target</code> representing the value of the wheels that will unlock the lock, return the minimum total number of turns required to open the lock, or -1 if it is impossible.\n</p>\n<p><b>Example 1:</b><br />\n<pre>\n<b>Input:</b> deadends = [\"0201\",\"0101\",\"0102\",\"1212\",\"2002\"], target = \"0202\"\n<b>Output:</b> 6\n<b>Explanation:</b>\nA sequence of valid moves would be \"0000\" -> \"1000\" -> \"1100\" -> \"1200\" -> \"1201\" -> \"1202\" -> \"0202\".\nNote that a sequence like \"0000\" -> \"0001\" -> \"0002\" -> \"0102\" -> \"0202\" would be invalid,\nbecause the wheels of the lock become stuck after the display becomes the dead end \"0102\".\n</pre>\n</p>\n<p><b>Example 2:</b><br />\n<pre>\n<b>Input:</b> deadends = [\"8888\"], target = \"0009\"\n<b>Output:</b> 1\n<b>Explanation:</b>\nWe can turn the last wheel in reverse to move from \"0000\" -> \"0009\".\n</pre>\n</p>\n<p><b>Example 3:</b><br />\n<pre>\n<b>Input:</b> deadends = [\"8887\",\"8889\",\"8878\",\"8898\",\"8788\",\"8988\",\"7888\",\"9888\"], target = \"8888\"\n<b>Output:</b> -1\n<b>Explanation:</b>\nWe can't reach the target without getting stuck.\n</pre>\n</p>\n<p><b>Example 4:</b><br />\n<pre>\n<b>Input:</b> deadends = [\"0000\"], target = \"8888\"\n<b>Output:</b> -1\n</pre>\n</p>\n<p><b>Note:</b><br>\n<ol>\n<li>The length of <code>deadends</code> will be in the range <code>[1, 500]</code>.</li>\n<li><code>target</code> will not be in the list <code>deadends</code>.</li>\n<li>Every string in <code>deadends</code> and the string <code>target</code> will be a string of 4 digits from the 10,000 possibilities <code>'0000'</code> to <code>'9999'</code>.</li>\n</ol>\n</p>\n<h3>Process:</h3>\n<ul>\n<li>这是一个树结构的问题，从0000开始，只改变一个值，就可以有8种变化，依此类推，每一个分支又可以产生8个分支</li>\n<li>所以就是搜索所有的子树，找到target的过程</li>\n<li>目标叶节点的所在的层级，就是我们想要的result</li>\n<li>其中在deadends里面的子树，都是不能再衍生的子树</li>\n<li>因为可以一致的转动，所以如何判定之前转过了呢？用个hashTable去维护</li>\n<li>\n<p>基本就是这个思路，不过得注意下 最少的这个条件，minimal</p>\n<ul>\n<li>其实在算法中 先进先出 最早return的 我觉得就是最小的了。。。</li>\n</ul>\n</li>\n<li>做出来了，卡的一个步骤在于 oneStepMove 的算法写错了 Number(xx) + 1 ，写成了  Number(xx + 1) ...</li>\n</ul>\n<h3>Answer:</h3>\n<h3>Others Answer:</h3>","timeToRead":2,"frontmatter":{"title":"Open the Lock"},"fields":{"slug":"/learn/queue-stack/queue-and-bfs/open-the-lock/"}}},"pageContext":{"slug":"/learn/queue-stack/queue-and-bfs/open-the-lock/","previous":"preserved","next":"preserved"}}}