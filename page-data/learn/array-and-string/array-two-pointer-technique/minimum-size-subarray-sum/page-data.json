{"componentChunkName":"component---src-templates-blog-post-tsx","path":"/learn/array-and-string/array-two-pointer-technique/minimum-size-subarray-sum/","result":{"data":{"site":{"siteMetadata":{"title":"Gatsby Default Starter","author":"@gatsbyjs"}},"markdownRemark":{"id":"db6a9eaa-77dd-5700-8651-2d2b24045834","html":"<h2>Minimum Size Subarray Sum ( mins)</h2>\n<h3>Question：</h3>\n<h5>Description:</h5>\n<ul>\n<li>Given an array of n positive integers and a positive integer s, find the minimal length of a contiguous subarray of which the sum ≥ s. If there isn't one, return 0 instead.</li>\n</ul>\n<h5>Note:</h5>\n<ul>\n<li>If you have figured out the O(n) solution, try coding another solution of which the time complexity is O(n log n).</li>\n</ul>\n<h5>Examples:</h5>\n<pre><code>Input: s = 7, nums = [2,3,1,2,4,3]\nOutput: 2\nExplanation: the subarray [4,3] has the minimal length under the problem constraint.\n</code></pre>\n<h3>Process:</h3>\n<ul>\n<li>O(n ^ 3) 挂了</li>\n<li>思考思考数学问题，因为算法很多时候跟数学问题息息相关</li>\n<li>\n<p>看了题解</p>\n<ul>\n<li>有点神奇</li>\n<li>总结一下：</li>\n<li>利用的一点就是 迭代累加，如果加上这个<strong>刚好</strong>大于等于s，那么子数组一定是包含当前元素的。</li>\n<li>然后从子数组签名剔除元素，直到不再 >= s</li>\n</ul>\n</li>\n</ul>\n<h3>Answer:</h3>\n<h3>Others Answer:</h3>","timeToRead":1,"frontmatter":{"title":"Minimum Size Subarray Sum"},"fields":{"slug":"/learn/array-and-string/array-two-pointer-technique/minimum-size-subarray-sum/"}}},"pageContext":{"slug":"/learn/array-and-string/array-two-pointer-technique/minimum-size-subarray-sum/","previous":"preserved","next":"preserved"}}}