{"componentChunkName":"component---src-templates-blog-index-tsx","path":"/","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"fields":{"slug":"/learn/array-101/in-place-operations/README/"},"html":"","frontmatter":{"title":"","timeSpent":null,"qId":null,"date":null,"conquered":null,"wrongTime":null,"withHelp":null}}},{"node":{"fields":{"slug":"/30days-challenge/week1/"},"html":"<h4><a href=\"https://leetcode.com/explore/challenge/card/30-day-leetcoding-challenge/528/week-1\">https://leetcode.com/explore/challenge/card/30-day-leetcoding-challenge/528/week-1</a></h4>","frontmatter":{"title":"","timeSpent":null,"qId":null,"date":null,"conquered":null,"wrongTime":null,"withHelp":null}}},{"node":{"fields":{"slug":"/30days-challenge/week2/"},"html":"<h4><a href=\"https://leetcode.com/explore/challenge/card/30-day-leetcoding-challenge/529/week-2/\">https://leetcode.com/explore/challenge/card/30-day-leetcoding-challenge/529/week-2/</a></h4>","frontmatter":{"title":"","timeSpent":null,"qId":null,"date":null,"conquered":null,"wrongTime":null,"withHelp":null}}},{"node":{"fields":{"slug":"/learn/queue-stack/README/"},"html":"<ul>\n<li>\n<p>为什么 BFS Breadth-first search 要queue呢？</p>\n<ul>\n<li>因为相当于一级一级来嘛，距离为0的，距离为1的，距离为2的 ...</li>\n</ul>\n</li>\n<li>\n<p>为什么 DFS Depth-fisrt search 要stack呢？</p>\n<ul>\n<li>因为相当于依次深度找，中间的都放到栈上，同时记录已经找到过的，然后每次出栈的时候判断已经找到过的（操作过的）在进行输出</li>\n</ul>\n</li>\n</ul>","frontmatter":{"title":"","timeSpent":null,"qId":null,"date":null,"conquered":null,"wrongTime":null,"withHelp":null}}},{"node":{"fields":{"slug":"/learn/array-101/conclusion/README/"},"html":"<h3>What's Next?</h3>\n<p>Let's recap what we looked at in this explore card:</p>\n<ul>\n<li>We explored what the Array data structure is all about.</li>\n<li>We looked at the Java syntax for creating Arrays.</li>\n<li>We looked at the Java syntax for reading and writing from Arrays.</li>\n<li>We designed basic insertion, deletion, and search algorithms for Arrays.</li>\n<li>We played around with in-place Array algorithms.</li>\n<li>We solved heaps of fun and exciting problems!</li>\n</ul>\n<p>Here at LeetCode, we've already started developing a follow-up Arrays Explore Card! In that card, we'll be going over some more advanced techniques for working with Arrays.</p>\n<p>What other techniques could there be with Arrays, you might be wondering? Well, wonder no more. Here is a quick taster!</p>\n<p><img src=\"https://leetcode.com/explore/learn/card/fun-with-arrays/523/conclusion/Figures/Array_Explore/Array_Basics_Conclusion_1.png\" alt=\"techs\"></p>\n<p>For now though, here's a few last questions for you to really practice what you've learned, and to get prepared for the next Arrays Explore Card!</p>","frontmatter":{"title":"","timeSpent":null,"qId":null,"date":null,"conquered":null,"wrongTime":null,"withHelp":null}}},{"node":{"fields":{"slug":"/learn/array-101/searching-for-items-in-an-array/README/"},"html":"<h3>Search in an Array</h3>\n<ol>\n<li>Linear Search</li>\n<li>If the index is not known, which is the case most of the time, then we can check every element in the Array. We continue checking elements until we find the element we're looking for, or we reach the end of the Array. This technique for finding an element by checking through all elements one by one is known as the linear search algorithm. In the worst case, a linear search ends up checking the entire Array. Therefore, the time complexity for a linear search is O(N)O(N).</li>\n<li>Binary Search</li>\n<li>There is another way of searching an Array. If the elements in the Array are in sorted order, then we can use binary search.</li>\n<li>Binary search is where we repeatedly look at the middle element in the Array, and determine whether the element we're looking for must be to the left, or to the right. Each time we do this, we're able to halve the number of elements we still need to search, making binary search a lot faster than linear search!</li>\n</ol>","frontmatter":{"title":"","timeSpent":null,"qId":null,"date":null,"conquered":null,"wrongTime":null,"withHelp":null}}},{"node":{"fields":{"slug":"/learn/array-and-string/array-two-pointer-technique/README/"},"html":"<h3>Two-pointer Technique</h3>\n<p>In the previous chapter, we solve some problems by iterating the array. Typically, we only use one pointer starting from the first element and ending at the last one to do iteration. However, sometimes, we might need to use two pointers at the same time to do the iteration.</p>\n<h4>Summary</h4>\n<ul>\n<li>\n<p>To summarize, one of the typical scenarios to use two-pointer technique is that you want to</p>\n<blockquote>\n<p>Iterate the array from two ends to the middle.</p>\n</blockquote>\n<blockquote>\n<p>And it is worth noting that this technique is often used in a sorted array.</p>\n</blockquote>\n</li>\n<li>\n<p>This is a very common scenario of using the two-pointer technique when you need:</p>\n<blockquote>\n<p>One slow-runner and one fast-runner at the same time.</p>\n</blockquote>\n<blockquote>\n<p>The key to solving this kind of problems is to <strong>Determine the movement strategy for both pointers.</strong></p>\n</blockquote>\n<blockquote>\n<p>Similar to the previous scenario, you might sometimes need to sort the array before using the two-pointer technique. And you might need a greedy thought to determine your movement strategy.</p>\n</blockquote>\n</li>\n</ul>","frontmatter":{"title":"","timeSpent":null,"qId":null,"date":null,"conquered":null,"wrongTime":null,"withHelp":null}}},{"node":{"fields":{"slug":"/learn/array-and-string/conclusion/README/"},"html":"<h3>Array-related Techniques</h3>\n<ul>\n<li>String (has been introduced in this card)</li>\n<li>Hash Table</li>\n<li>Linked List</li>\n<li>Queue</li>\n<li>Stack</li>\n</ul>","frontmatter":{"title":"","timeSpent":null,"qId":null,"date":null,"conquered":null,"wrongTime":null,"withHelp":null}}},{"node":{"fields":{"slug":"/learn/array-and-string/introduction-to-2d-array/README/"},"html":"<h3>Introduction to 2D Array</h3>\n<p>In the previous chapter, we have learned about the <code>one-dimensional array</code>. However, sometimes, we might need a <code>multidimensional array</code> which is more suitable for more complex structures like table or matrix.</p>\n<p>In this chapter, we are going to focus on the <code>two-dimensional array</code> to explain:</p>\n<p>How does a multidimensional array work?\nHow to use a two-dimensional array to solve problems?</p>","frontmatter":{"title":"","timeSpent":null,"qId":null,"date":null,"conquered":null,"wrongTime":null,"withHelp":null}}},{"node":{"fields":{"slug":"/learn/array-and-string/introduction-to-string/README/"},"html":"<h3>Immutable String - Problems &#x26; Solutions</h3>\n<h4>Tips:</h4>\n<ul>\n<li>You should be aware of the time complexity of these built-in operations.</li>\n<li>For instance, if the length of the string is N, the time complexity of both finding operation and substring operation is O(N).</li>\n<li>Also, in languages which the string is immutable, you should be careful with the concatenation operation (we will explain this in next article as well).</li>\n<li>Never forget to take the time complexity of built-in operations into consideration when you compute the time complexity for your solution.</li>\n</ul>\n<h4>Immutable String</h4>\n<pre><code class=\"language-java\">public class Main {\n    public static void main(String[] args) {\n        String s = \"\";\n        int n = 10000;\n        for (int i = 0; i &#x3C; n; i++) {\n            s += \"hello\";\n        }\n    }\n}\n</code></pre>\n<p>In Java, since the string is immutable, concatenation works by first allocating enough space for the new string, copy the contents from the old string and append to the new string.</p>\n<p>Therefore, the time complexity in total will be:</p>\n<p>   5 + 5 × 2 + 5 × 3 + … + 5 × n\n= 5 × (1 + 2 + 3 + … + n)\n= 5 × n × (n + 1) / 2,</p>\n<p>which is O(n2).</p>\n<h4>Solution</h4>\n<ol>\n<li><strong>If you did want your string to be mutable, you can convert it to a char array.</strong></li>\n<li>If you have to concatenate strings often, it will be better to use some other data structures like StringBuilder. The below code runs in O(n) complexity.</li>\n</ol>\n<h4>reference:</h4>\n<ul>\n<li><a href=\"https://leetcode.com/explore/learn/card/array-and-string/203/introduction-to-string/1184/\">https://leetcode.com/explore/learn/card/array-and-string/203/introduction-to-string/1184/</a></li>\n</ul>","frontmatter":{"title":"","timeSpent":null,"qId":null,"date":null,"conquered":null,"wrongTime":null,"withHelp":null}}},{"node":{"fields":{"slug":"/learn/queue-stack/queue-and-bfs/README/"},"html":"<h3>Queue and BFS</h3>\n<p>One common application of Breadth-first Search (BFS) is to find the shortest path from the root node to the target node.</p>\n<blockquote>\n<p>In the first round, we process the root node. In the second round, we process the nodes next to the root node; in the third round, we process the nodes which are two steps from the root node; so on and so forth.</p>\n</blockquote>\n<blockquote>\n<p>Similar to tree's level-order traversal, the nodes closer to the root node will be traversed earlier.</p>\n</blockquote>\n<blockquote>\n<p>If a node X is added to the queue in the kth round, the length of the shortest path between the root node and X is exactly k. That is to say, you are already in the shortest path the first time you find the target node.</p>\n</blockquote>","frontmatter":{"title":"","timeSpent":null,"qId":null,"date":null,"conquered":null,"wrongTime":null,"withHelp":null}}},{"node":{"fields":{"slug":"/learn/queue-stack/conclusion/keys-and-rooms/"},"html":"<h2>Keys and Rooms</h2>\n<h3>Question：</h3>\n<p>There are <code>N</code> rooms and you start in room <code>0</code>.&nbsp; Each room has a distinct number in <code>0, 1, 2, ..., N-1</code>, and each room may have&nbsp;some keys to access the next room.&nbsp;</p>\n<p>Formally, each room <code>i</code>&nbsp;has a list of keys <code>rooms[i]</code>, and each key <code>rooms[i][j]</code> is an integer in <code>[0, 1, ..., N-1]</code> where <code>N = rooms.length</code>.&nbsp; A key <code>rooms[i][j] = v</code>&nbsp;opens the room with number <code>v</code>.</p>\n<p>Initially, all the rooms start locked (except for room <code>0</code>).&nbsp;</p>\n<p>You can walk back and forth between rooms freely.</p>\n<p>Return <code>true</code>&nbsp;if and only if you can enter&nbsp;every room.</p>\n<ol>\n</ol>\n<p><strong>Example 1:</strong></p>\n<pre>\n<strong>Input: </strong>[[1],[2],[3],[]]\n<strong>Output: </strong>true\n<strong>Explanation:  </strong>\nWe start in room 0, and pick up key 1.\nWe then go to room 1, and pick up key 2.\nWe then go to room 2, and pick up key 3.\nWe then go to room 3.  Since we were able to go to every room, we return true.\n</pre>\n<p><strong>Example 2:</strong></p>\n<pre>\n<strong>Input: </strong>[[1,3],[3,0,1],[2],[0]]\n<strong>Output: </strong>false\n<strong>Explanation: </strong>We can&#39;t enter the room with number 2.\n</pre>\n<p><b>Note:</b></p>\n<ol>\n\t<li><code>1 &lt;= rooms.length &lt;=&nbsp;1000</code></li>\n\t<li><code>0 &lt;= rooms[i].length &lt;= 1000</code></li>\n\t<li>The number of keys in all rooms combined is at most&nbsp;<code>3000</code>.</li>\n</ol>\n<h3>Process:</h3>\n<ul>\n<li>placeholder</li>\n</ul>\n<h3>Answer:</h3>\n<h3>Others Answer:</h3>","frontmatter":{"title":"Keys and Rooms","timeSpent":30,"qId":871,"date":"2020-07-03","conquered":true,"wrongTime":0,"withHelp":false}}},{"node":{"fields":{"slug":"/learn/queue-stack/conclusion/01-matrix/"},"html":"<h2>01 Matrix</h2>\n<h3>Question：</h3>\n<p>Given a matrix consists of 0 and 1, find the distance of the nearest 0 for each cell.</p>\n<p>The distance between two adjacent cells is 1.</p>\n<p>&nbsp;</p>\n<p><b>Example 1: </b></p>\n<pre>\n<strong>Input:</strong>\n[[0,0,0],\n [0,1,0],\n [0,0,0]]\n\n<strong>Output:</strong>\n[[0,0,0],\n&nbsp;[0,1,0],\n&nbsp;[0,0,0]]\n</pre>\n<p><b>Example 2: </b></p>\n<pre>\n<b>Input:</b>\n[[0,0,0],\n [0,1,0],\n [1,1,1]]\n\n<strong>Output:</strong>\n[[0,0,0],\n [0,1,0],\n [1,2,1]]\n</pre>\n<p>&nbsp;</p>\n<p><b>Note:</b></p>\n<ol>\n\t<li>The number of elements of the given matrix will not exceed 10,000.</li>\n\t<li>There are at least one 0 in the given matrix.</li>\n\t<li>The cells are adjacent in only four directions: up, down, left and right.</li>\n</ol>\n<h3>Process:</h3>\n<ul>\n<li>针对每个cell，他的val = Math.min(周围4个临近的cell的val + 1)</li>\n<li>可以避免重复的运算</li>\n<li>之前就是这样的递归，但是这样有个问题，循环了，左右一样，上下一样的情况处理的不好</li>\n<li>\n<p><a href=\"https://www.youtube.com/watch?v=luUo7hqLgw0\">https://www.youtube.com/watch?v=luUo7hqLgw0</a></p>\n<ul>\n<li>看了一个视频 有了点启发，因为只有0和1，所以对1来说是 最短路径问题</li>\n</ul>\n</li>\n<li>后来没有按照视频里的解法，自己想了个办法做了这道题，突然就PASS了，激动</li>\n</ul>\n<h3>Answer:</h3>\n<h3>Others Answer:</h3>","frontmatter":{"title":"01 Matrix","timeSpent":75,"qId":542,"date":"2020-07-01","conquered":true,"wrongTime":2,"withHelp":true}}},{"node":{"fields":{"slug":"/learn/queue-stack/conclusion/decode-string/"},"html":"<h2>Decode String</h2>\n<h3>Question：</h3>\n<p>Given an encoded string, return its decoded string.</p>\n<p>The encoding rule is: <code>k[encoded_string]</code>, where the <i>encoded_string</i> inside the square brackets is being repeated exactly <i>k</i> times. Note that <i>k</i> is guaranteed to be a positive integer.</p>\n<p>You may assume that the input string is always valid; No extra white spaces, square brackets are well-formed, etc.</p>\n<p>Furthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, <i>k</i>. For example, there won&#39;t be input like <code>3a</code> or <code>2[4]</code>.</p>\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n<pre><strong>Input:</strong> s = \"3[a]2[bc]\"\n<strong>Output:</strong> \"aaabcbc\"\n</pre><p><strong>Example 2:</strong></p>\n<pre><strong>Input:</strong> s = \"3[a2[c]]\"\n<strong>Output:</strong> \"accaccacc\"\n</pre><p><strong>Example 3:</strong></p>\n<pre><strong>Input:</strong> s = \"2[abc]3[cd]ef\"\n<strong>Output:</strong> \"abcabccdcdcdef\"\n</pre><p><strong>Example 4:</strong></p>\n<pre><strong>Input:</strong> s = \"abc3[cd]xyz\"\n<strong>Output:</strong> \"abccdcdcdxyz\"\n</pre>\n<h3>Process:</h3>\n<ul>\n<li>这个乍一看跟 什么 栈实现的四则运算有异曲同工之妙，四则运算的原则是右边括号不入栈，这个也是一样</li>\n<li>从左边开始扫描，压栈，遇到右边的括号，就处理下，处理到最近的左括号为止。</li>\n<li>js的基础知识 join方法 不传参数默认会认为是 ','这个点我忘记了，我以为直接就是没有separator了。。。</li>\n</ul>\n<h3>Answer:</h3>\n<h3>Others Answer:</h3>","frontmatter":{"title":"Decode String","timeSpent":37,"qId":394,"date":"2020-06-30","conquered":true,"wrongTime":1,"withHelp":false}}},{"node":{"fields":{"slug":"/learn/queue-stack/conclusion/flood-fill/"},"html":"<h2>Flood Fill</h2>\n<h3>Question：</h3>\n<p>\nAn <code>image</code> is represented by a 2-D array of integers, each integer representing the pixel value of the image (from 0 to 65535).\n</p><p>\nGiven a coordinate <code>(sr, sc)</code> representing the starting pixel (row and column) of the flood fill, and a pixel value <code>newColor</code>, \"flood fill\" the image.\n</p><p>\nTo perform a \"flood fill\", consider the starting pixel, plus any pixels connected 4-directionally to the starting pixel of the same color as the starting pixel, plus any pixels connected 4-directionally to those pixels (also with the same color as the starting pixel), and so on.  Replace the color of all of the aforementioned pixels with the newColor.\n</p><p>\nAt the end, return the modified image.\n</p>\n<p><b>Example 1:</b><br />\n<pre>\n<b>Input:</b>\nimage = [[1,1,1],[1,1,0],[1,0,1]]\nsr = 1, sc = 1, newColor = 2\n<b>Output:</b> [[2,2,2],[2,2,0],[2,0,1]]\n<b>Explanation:</b>\nFrom the center of the image (with position (sr, sc) = (1, 1)), all pixels connected\nby a path of the same color as the starting pixel are colored with the new color.\nNote the bottom corner is not colored 2, because it is not 4-directionally connected\nto the starting pixel.\n</pre>\n</p>\n<p><b>Note:</b>\n<li>The length of <code>image</code> and <code>image[0]</code> will be in the range <code>[1, 50]</code>.</li>\n<li>The given starting pixel will satisfy <code>0 <= sr < image.length</code> and <code>0 <= sc < image[0].length</code>.</li>\n<li>The value of each color in <code>image[i][j]</code> and <code>newColor</code> will be an integer in <code>[0, 65535]</code>.</li>\n</p>\n<h3>Process:</h3>\n<ul>\n<li>\n<p>这道题 题目意思都没有读清楚。。。</p>\n<ul>\n<li>(also with the same color as the starting pixel)</li>\n<li>多么关键呀。。。 跟初始的同一个颜色的才会填充</li>\n</ul>\n</li>\n<li>8分钟 查阅资料后，弄懂了题目的意思</li>\n<li>这道题 错了一次，因为没有判断 等于原color 不等于新color</li>\n</ul>\n<h3>Answer:</h3>\n<h3>Others Answer:</h3>","frontmatter":{"title":"Flood Fill","timeSpent":34,"qId":733,"date":"2020-06-30","conquered":true,"wrongTime":1,"withHelp":true}}},{"node":{"fields":{"slug":"/learn/queue-stack/conclusion/implement-queue-using-stack/"},"html":"<h2>Implement Queue using Stacks</h2>\n<h3>Question：</h3>\n<p>Implement the following operations of a queue using stacks.</p>\n<ul>\n\t<li>push(x) -- Push element x to the back of queue.</li>\n\t<li>pop() -- Removes the element from in front of queue.</li>\n\t<li>peek() -- Get the front element.</li>\n\t<li>empty() -- Return whether the queue is empty.</li>\n</ul>\n<p><b>Example:</b></p>\n<pre>\nMyQueue queue = new MyQueue();\n\nqueue.push(1);\nqueue.push(2);\nqueue.peek();  // returns 1\nqueue.pop();   // returns 1\nqueue.empty(); // returns false</pre>\n<p><b>Notes:</b></p>\n<ul>\n\t<li>You must use <i>only</i> standard operations of a stack -- which means only <code>push to top</code>, <code>peek/pop from top</code>, <code>size</code>, and <code>is empty</code> operations are valid.</li>\n\t<li>Depending on your language, stack may not be supported natively. You may simulate a stack by using a list or deque (double-ended queue), as long as you use only standard operations of a stack.</li>\n\t<li>You may assume that all operations are valid (for example, no pop or peek operations will be called on an empty queue).</li>\n</ul>\n<h3>Process:</h3>\n<ul>\n<li>placeholder</li>\n</ul>\n<h3>Answer:</h3>\n<h3>Others Answer:</h3>","frontmatter":{"title":"Implement Queue using Stacks","timeSpent":8,"qId":232,"date":"2020-06-29","conquered":false,"wrongTime":1,"withHelp":false}}},{"node":{"fields":{"slug":"/learn/queue-stack/conclusion/implement-stack-using-queues/"},"html":"<h2>Implement Stack using Queues</h2>\n<h3>Question：</h3>\n<p>Implement the following operations of a stack using queues.</p>\n<ul>\n\t<li>push(x) -- Push element x onto stack.</li>\n\t<li>pop() -- Removes the element on top of the stack.</li>\n\t<li>top() -- Get the top element.</li>\n\t<li>empty() -- Return whether the stack is empty.</li>\n</ul>\n<p><b>Example:</b></p>\n<pre>\nMyStack stack = new MyStack();\n\nstack.push(1);\nstack.push(2);\nstack.top();   // returns 2\nstack.pop();   // returns 2\nstack.empty(); // returns false</pre>\n<p><b>Notes:</b></p>\n<ul>\n\t<li>You must use <i>only</i> standard operations of a queue -- which means only <code>push to back</code>, <code>peek/pop from front</code>, <code>size</code>, and <code>is empty</code> operations are valid.</li>\n\t<li>Depending on your language, queue may not be supported natively. You may simulate a queue by using a list or deque (double-ended queue), as long as you use only standard operations of a queue.</li>\n\t<li>You may assume that all operations are valid (for example, no pop or top operations will be called on an empty stack).</li>\n</ul>\n<h3>Process:</h3>\n<ul>\n<li>placeholder</li>\n</ul>\n<h3>Answer:</h3>\n<h3>Others Answer:</h3>","frontmatter":{"title":"Implement Stack using Queues","timeSpent":5,"qId":225,"date":"2020-06-29","conquered":false,"wrongTime":0,"withHelp":false}}},{"node":{"fields":{"slug":"/learn/queue-stack/stack-and-dfs/binary-tree-inorder-traversal/"},"html":"<h2>Binary Tree Inorder Traversal</h2>\n<h3>Question：</h3>\n<p>Given a binary tree, return the <em>inorder</em> traversal of its nodes&#39; values.</p>\n<p><strong>Example:</strong></p>\n<pre>\n<strong>Input:</strong> [1,null,2,3]\n   1\n    \\\n     2\n    /\n   3\n\n<strong>Output:</strong> [1,3,2]</pre>\n<p><strong>Follow up:</strong> Recursive solution is trivial, could you do it iteratively?</p>\n<h3>Process:</h3>\n<ul>\n<li>placeholder</li>\n</ul>\n<h3>Answer:</h3>\n<h3>Others Answer:</h3>","frontmatter":{"title":"Binary Tree Inorder Traversal","timeSpent":20,"qId":94,"date":"2020-06-29","conquered":false,"wrongTime":0,"withHelp":false}}},{"node":{"fields":{"slug":"/learn/queue-stack/stack-and-dfs/target-sum/"},"html":"<h2>Target Sum</h2>\n<h3>Question：</h3>\n<p>You are given a list of non-negative integers, a1, a2, ..., an, and a target, S. Now you have 2 symbols <code>+</code> and <code>-</code>. For each integer, you should choose one from <code>+</code> and <code>-</code> as its new symbol.</p>\n<p>Find out how many ways to assign symbols to make sum of integers equal to target S.</p>\n<p><b>Example 1:</b></p>\n<pre>\n<b>Input:</b> nums is [1, 1, 1, 1, 1], S is 3.\n<b>Output:</b> 5\n<b>Explanation:</b>\n\n-1+1+1+1+1 = 3\n+1-1+1+1+1 = 3\n+1+1-1+1+1 = 3\n+1+1+1-1+1 = 3\n+1+1+1+1-1 = 3\n\nThere are 5 ways to assign symbols to make the sum of nums be target 3.\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n<ul>\n\t<li>The length of the given array is positive and will not exceed 20.</li>\n\t<li>The sum of elements in the given array will not exceed 1000.</li>\n\t<li>Your output answer is guaranteed to be fitted in a 32-bit integer.</li>\n</ul>\n<h3>Process:</h3>\n<ul>\n<li>这道题也不知道为什么放在DFS 和 stack里面，我是用递归解决的，分而治之，变成很小的子问题</li>\n<li>我知道了，递归本来就是栈操作</li>\n</ul>\n<h3>Answer:</h3>\n<h3>Others Answer:</h3>","frontmatter":{"title":"Target Sum","timeSpent":30,"qId":494,"date":"2020-06-29","conquered":true,"wrongTime":0,"withHelp":false}}},{"node":{"fields":{"slug":"/learn/queue-stack/stack-and-dfs/clone-graph/"},"html":"<h2>Clone Graph</h2>\n<h3>Question：</h3>\n<p>Given a reference of a node in a&nbsp;<strong><a href=\"https://en.wikipedia.org/wiki/Connectivity_(graph_theory)#Connected_graph\" target=\"_blank\">connected</a></strong>&nbsp;undirected graph.</p>\n<p>Return a <a href=\"https://en.wikipedia.org/wiki/Object_copying#Deep_copy\" target=\"_blank\"><strong>deep copy</strong></a> (clone) of the graph.</p>\n<p>Each node in the graph contains a val (<code>int</code>) and a list (<code>List[Node]</code>) of its neighbors.</p>\n<pre>\nclass Node {\n    public int val;\n    public List&lt;Node&gt; neighbors;\n}\n</pre>\n<p>&nbsp;</p>\n<p><strong>Test case format:</strong></p>\n<p>For simplicity sake, each&nbsp;node&#39;s value is the same as the node&#39;s index (1-indexed). For example, the first node with&nbsp;<code>val = 1</code>, the second node with <code>val = 2</code>, and so on.&nbsp;The graph is represented in the test case using an adjacency list.</p>\n<p><b>Adjacency list</b>&nbsp;is a collection of unordered&nbsp;<b>lists</b>&nbsp;used to represent a finite graph. Each&nbsp;list&nbsp;describes the set of neighbors of a node in the graph.</p>\n<p>The given node will&nbsp;always be the first node&nbsp;with&nbsp;<code>val = 1</code>. You must return the <strong>copy of the given node</strong> as a reference to the cloned graph.</p>\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/11/04/133_clone_graph_question.png\" style=\"width: 500px; height: 550px;\" />\n<pre>\n<strong>Input:</strong> adjList = [[2,4],[1,3],[2,4],[1,3]]\n<strong>Output:</strong> [[2,4],[1,3],[2,4],[1,3]]\n<strong>Explanation:</strong> There are 4 nodes in the graph.\n1st node (val = 1)&#39;s neighbors are 2nd node (val = 2) and 4th node (val = 4).\n2nd node (val = 2)&#39;s neighbors are 1st node (val = 1) and 3rd node (val = 3).\n3rd node (val = 3)&#39;s neighbors are 2nd node (val = 2) and 4th node (val = 4).\n4th node (val = 4)&#39;s neighbors are 1st node (val = 1) and 3rd node (val = 3).\n</pre>\n<p><strong>Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/01/07/graph.png\" style=\"width: 163px; height: 148px;\" />\n<pre>\n<strong>Input:</strong> adjList = [[]]\n<strong>Output:</strong> [[]]\n<strong>Explanation:</strong> Note that the input contains one empty list. The graph consists of only one node with val = 1 and it does not have any neighbors.\n</pre>\n<p><strong>Example 3:</strong></p>\n<pre>\n<strong>Input:</strong> adjList = []\n<strong>Output:</strong> []\n<strong>Explanation:</strong> This an empty graph, it does not have any nodes.\n</pre>\n<p><strong>Example 4:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/01/07/graph-1.png\" style=\"width: 272px; height: 133px;\" />\n<pre>\n<strong>Input:</strong> adjList = [[2],[1]]\n<strong>Output:</strong> [[2],[1]]\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n<ul>\n\t<li><code>1 &lt;= Node.val &lt;= 100</code></li>\n\t<li><code>Node.val</code> is unique for each node.</li>\n\t<li>Number of Nodes will not exceed 100.</li>\n\t<li>There is no repeated edges and no self-loops in the graph.</li>\n\t<li>The Graph is connected and all nodes can be visited starting from the given node.</li>\n</ul>\n<h3>Process:</h3>\n<ul>\n<li>placeholder</li>\n</ul>\n<h3>Answer:</h3>\n<h3>Others Answer:</h3>","frontmatter":{"title":"Clone Graph","timeSpent":40,"qId":133,"date":"2020-06-22","conquered":false,"wrongTime":3,"withHelp":true}}},{"node":{"fields":{"slug":"/learn/queue-stack/queue-and-bfs/evaluate-reverse-polish-notation/"},"html":"<h2>Evaluate Reverse Polish Notation</h2>\n<h3>Question：</h3>\n<p>Evaluate the value of an arithmetic expression in <a href=\"http://en.wikipedia.org/wiki/Reverse_Polish_notation\" target=\"_blank\">Reverse Polish Notation</a>.</p>\n<p>Valid operators are <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>. Each operand may be an integer or another expression.</p>\n<p><strong>Note:</strong></p>\n<ul>\n\t<li>Division between two integers should truncate toward zero.</li>\n\t<li>The given RPN expression is always valid. That means the expression would always evaluate to a result and there won&#39;t&nbsp;be any&nbsp;divide&nbsp;by zero operation.</li>\n</ul>\n<p><strong>Example 1:</strong></p>\n<pre>\n<strong>Input:</strong> [&quot;2&quot;, &quot;1&quot;, &quot;+&quot;, &quot;3&quot;, &quot;*&quot;]\n<strong>Output:</strong> 9\n<strong>Explanation:</strong> ((2 + 1) * 3) = 9\n</pre>\n<p><strong>Example 2:</strong></p>\n<pre>\n<strong>Input:</strong> [&quot;4&quot;, &quot;13&quot;, &quot;5&quot;, &quot;/&quot;, &quot;+&quot;]\n<strong>Output:</strong> 6\n<strong>Explanation:</strong> (4 + (13 / 5)) = 6\n</pre>\n<p><strong>Example 3:</strong></p>\n<pre>\n<strong>Input:</strong> [&quot;10&quot;, &quot;6&quot;, &quot;9&quot;, &quot;3&quot;, &quot;+&quot;, &quot;-11&quot;, &quot;*&quot;, &quot;/&quot;, &quot;*&quot;, &quot;17&quot;, &quot;+&quot;, &quot;5&quot;, &quot;+&quot;]\n<strong>Output:</strong> 22\n<strong>Explanation:</strong>\n  ((10 * (6 / ((9 + 3) * -11))) + 17) + 5\n= ((10 * (6 / (12 * -11))) + 17) + 5\n= ((10 * (6 / -132)) + 17) + 5\n= ((10 * 0) + 17) + 5\n= (0 + 17) + 5\n= 17 + 5\n= 22\n</pre>\n<h3>Process:</h3>\n<ul>\n<li>Division between two integers should truncate toward zero 这句话理解不透彻导致错了一次</li>\n<li>原来Js中有这样的一个方法 Math.trunc()</li>\n</ul>\n<h3>Answer:</h3>\n<h3>Others Answer:</h3>","frontmatter":{"title":"Evaluate Reverse Polish Notation","timeSpent":35,"qId":150,"date":"2020-05-29","conquered":false,"wrongTime":1,"withHelp":false}}},{"node":{"fields":{"slug":"/learn/queue-stack/last-in-first-out-data-structure/daily-temperatures/"},"html":"<h2>Daily Temperatures</h2>\n<h3>Question：</h3>\n<p>\nGiven a list of daily temperatures <code>T</code>, return a list such that, for each day in the input, tells you how many days you would have to wait until a warmer temperature.  If there is no future day for which this is possible, put <code>0</code> instead.\n</p><p>\nFor example, given the list of temperatures <code>T = [73, 74, 75, 71, 69, 72, 76, 73]</code>, your output should be <code>[1, 1, 4, 2, 1, 1, 0, 0]</code>.\n</p>\n<p><b>Note:</b>\nThe length of <code>temperatures</code> will be in the range <code>[1, 30000]</code>.\nEach temperature will be an integer in the range <code>[30, 100]</code>.\n</p>\n<h3>Process:</h3>\n<ul>\n<li>仔细看了下题目意思，要我们求的是相对向前这个迭代的天气值，什么时候会有一个更大值的出现</li>\n<li>暂时有一种n ^ 2的思路，但是没有用到stack，先做吧，看看能不能acc</li>\n</ul>\n<h3>Answer:</h3>\n<h3>Others Answer:</h3>","frontmatter":{"title":"Daily Temperatures","timeSpent":0,"qId":739,"date":"2020-05-28","conquered":true,"wrongTime":0,"withHelp":false}}},{"node":{"fields":{"slug":"/learn/queue-stack/last-in-first-out-data-structure/valid-parentheses/"},"html":"<h2>Valid Parentheses</h2>\n<h3>Question：</h3>\n<p>Given a string containing just the characters <code>&#39;(&#39;</code>, <code>&#39;)&#39;</code>, <code>&#39;{&#39;</code>, <code>&#39;}&#39;</code>, <code>&#39;[&#39;</code> and <code>&#39;]&#39;</code>, determine if the input string is valid.</p>\n<p>An input string is valid if:</p>\n<ol>\n\t<li>Open brackets must be closed by the same type of brackets.</li>\n\t<li>Open brackets must be closed in the correct order.</li>\n</ol>\n<p>Note that an empty string is&nbsp;also considered valid.</p>\n<p><strong>Example 1:</strong></p>\n<pre>\n<strong>Input:</strong> &quot;()&quot;\n<strong>Output:</strong> true\n</pre>\n<p><strong>Example 2:</strong></p>\n<pre>\n<strong>Input:</strong> &quot;()[]{}&quot;\n<strong>Output:</strong> true\n</pre>\n<p><strong>Example 3:</strong></p>\n<pre>\n<strong>Input:</strong> &quot;(]&quot;\n<strong>Output:</strong> false\n</pre>\n<p><strong>Example 4:</strong></p>\n<pre>\n<strong>Input:</strong> &quot;([)]&quot;\n<strong>Output:</strong> false\n</pre>\n<p><strong>Example 5:</strong></p>\n<pre>\n<strong>Input:</strong> &quot;{[]}&quot;\n<strong>Output:</strong> true\n</pre>","frontmatter":{"title":"Valid Parentheses","timeSpent":24,"qId":20,"date":"2020-05-28","conquered":false,"wrongTime":0,"withHelp":false}}},{"node":{"fields":{"slug":"/learn/queue-stack/queue-and-bfs/open-the-lock/"},"html":"<h2>Open the Lock</h2>\n<h3>Question：</h3>\n<p>\nYou have a lock in front of you with 4 circular wheels.  Each wheel has 10 slots: <code>'0', '1', '2', '3', '4', '5', '6', '7', '8', '9'</code>.  The wheels can rotate freely and wrap around: for example we can turn <code>'9'</code> to be <code>'0'</code>, or <code>'0'</code> to be <code>'9'</code>.  Each move consists of turning one wheel one slot.\n</p><p>\nThe lock initially starts at <code>'0000'</code>, a string representing the state of the 4 wheels.\n</p><p>\nYou are given a list of <code>deadends</code> dead ends, meaning if the lock displays any of these codes, the wheels of the lock will stop turning and you will be unable to open it.\n</p><p>\nGiven a <code>target</code> representing the value of the wheels that will unlock the lock, return the minimum total number of turns required to open the lock, or -1 if it is impossible.\n</p>\n<p><b>Example 1:</b><br />\n<pre>\n<b>Input:</b> deadends = [\"0201\",\"0101\",\"0102\",\"1212\",\"2002\"], target = \"0202\"\n<b>Output:</b> 6\n<b>Explanation:</b>\nA sequence of valid moves would be \"0000\" -> \"1000\" -> \"1100\" -> \"1200\" -> \"1201\" -> \"1202\" -> \"0202\".\nNote that a sequence like \"0000\" -> \"0001\" -> \"0002\" -> \"0102\" -> \"0202\" would be invalid,\nbecause the wheels of the lock become stuck after the display becomes the dead end \"0102\".\n</pre>\n</p>\n<p><b>Example 2:</b><br />\n<pre>\n<b>Input:</b> deadends = [\"8888\"], target = \"0009\"\n<b>Output:</b> 1\n<b>Explanation:</b>\nWe can turn the last wheel in reverse to move from \"0000\" -> \"0009\".\n</pre>\n</p>\n<p><b>Example 3:</b><br />\n<pre>\n<b>Input:</b> deadends = [\"8887\",\"8889\",\"8878\",\"8898\",\"8788\",\"8988\",\"7888\",\"9888\"], target = \"8888\"\n<b>Output:</b> -1\n<b>Explanation:</b>\nWe can't reach the target without getting stuck.\n</pre>\n</p>\n<p><b>Example 4:</b><br />\n<pre>\n<b>Input:</b> deadends = [\"0000\"], target = \"8888\"\n<b>Output:</b> -1\n</pre>\n</p>\n<p><b>Note:</b><br>\n<ol>\n<li>The length of <code>deadends</code> will be in the range <code>[1, 500]</code>.</li>\n<li><code>target</code> will not be in the list <code>deadends</code>.</li>\n<li>Every string in <code>deadends</code> and the string <code>target</code> will be a string of 4 digits from the 10,000 possibilities <code>'0000'</code> to <code>'9999'</code>.</li>\n</ol>\n</p>\n<h3>Process:</h3>\n<ul>\n<li>这是一个树结构的问题，从0000开始，只改变一个值，就可以有8种变化，依此类推，每一个分支又可以产生8个分支</li>\n<li>所以就是搜索所有的子树，找到target的过程</li>\n<li>目标叶节点的所在的层级，就是我们想要的result</li>\n<li>其中在deadends里面的子树，都是不能再衍生的子树</li>\n<li>因为可以一致的转动，所以如何判定之前转过了呢？用个hashTable去维护</li>\n<li>\n<p>基本就是这个思路，不过得注意下 最少的这个条件，minimal</p>\n<ul>\n<li>其实在算法中 先进先出 最早return的 我觉得就是最小的了。。。</li>\n</ul>\n</li>\n<li>做出来了，卡的一个步骤在于 oneStepMove 的算法写错了 Number(xx) + 1 ，写成了  Number(xx + 1) ...</li>\n</ul>\n<h3>Answer:</h3>\n<h3>Others Answer:</h3>","frontmatter":{"title":"Open the Lock","timeSpent":63,"qId":753,"date":"2020-05-28","conquered":false,"wrongTime":0,"withHelp":false}}},{"node":{"fields":{"slug":"/learn/queue-stack/queue-and-bfs/perfect-squares/"},"html":"<h2>Perfect Squares</h2>\n<h3>Question：</h3>\n<p>Given a positive integer <i>n</i>, find the least number of perfect square numbers (for example, <code>1, 4, 9, 16, ...</code>) which sum to <i>n</i>.</p>\n<p><b>Example 1:</b></p>\n<pre>\n<b>Input:</b> <i>n</i> = <code>12</code>\n<b>Output:</b> 3\n<strong>Explanation: </strong><code>12 = 4 + 4 + 4.</code></pre>\n<p><b>Example 2:</b></p>\n<pre>\n<b>Input:</b> <i>n</i> = <code>13</code>\n<b>Output:</b> 2\n<strong>Explanation: </strong><code>13 = 4 + 9.</code></pre>\n<h3>Process:</h3>\n<ul>\n<li>有点棘手，一时间不知道怎么处理</li>\n<li>首先肯定都是可以的，因为 大不了都是1，返回就是这个数本身嘛</li>\n<li>然后有点像动态规划的问题？因为依赖于之前的</li>\n<li>就是一个划分成子问题，分而治之去求解的过程，同时记录已经求过的值避免重复计算</li>\n<li>不知道为什么会出现在队列里面</li>\n</ul>\n<h3>Answer:</h3>\n<h3>Others Answer:</h3>","frontmatter":{"title":"Perfect Squares","timeSpent":30,"qId":279,"date":"2020-05-28","conquered":false,"wrongTime":0,"withHelp":false}}},{"node":{"fields":{"slug":"/learn/queue-stack/queue-and-bfs/number-of-islands/"},"html":"<h2>Number of Islands</h2>\n<h3>Question：</h3>\n<p>Given a 2d grid map of <code>&#39;1&#39;</code>s (land) and <code>&#39;0&#39;</code>s (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.</p>\n<p><b>Example 1:</b></p>\n<pre>\n<strong>Input:</strong>\n11110\n11010\n11000\n00000\n\n<strong>Output:</strong>&nbsp;1\n</pre>\n<p><b>Example 2:</b></p>\n<pre>\n<strong>Input:</strong>\n11000\n11000\n00100\n00011\n\n<strong>Output: </strong>3\n</pre>\n<h3>Process:</h3>\n<p>之前遇到过，不会做，这一遍看了帮助做成了</p>\n<h3>Answer:</h3>\n<h3>Others Answer:</h3>\n<p>看了 youtube视频 <a href=\"https://www.youtube.com/watch?v=o8S2bO3pmO4\">https://www.youtube.com/watch?v=o8S2bO3pmO4</a>\n通过BFS 然后不断的把为1的置成0这种方法还挺有用感觉</p>","frontmatter":{"title":"Number of Islands","timeSpent":0,"qId":200,"date":"2020-05-27","conquered":false,"wrongTime":0,"withHelp":true}}},{"node":{"fields":{"slug":"/learn/queue-stack/first-in-first-out-data-structure/design-circular-queue/"},"html":"<h2>Design Circular Queue</h2>\n<h3>Question：</h3>\n<p>Design your implementation of the circular queue. The circular queue is a linear data structure in which the operations are performed based on FIFO (First In First Out) principle and the last position is connected back to the first position to make a circle. It is also called &quot;Ring Buffer&quot;.</p>\n<p>One of the benefits of the circular queue is that we can make use of the spaces in front of the queue. In a normal queue, once the queue becomes full, we cannot insert the next element even if there is a space in front of the queue. But using the circular queue, we can use the space to store new values.</p>\n<p>Your implementation should support following operations:</p>\n<ul>\n\t<li><code>MyCircularQueue(k)</code>: Constructor, set the size of the queue to be k.</li>\n\t<li><code>Front</code>: Get the front item from the queue. If the queue is empty, return -1.</li>\n\t<li><code>Rear</code>: Get the last item from the queue. If the queue is empty, return -1.</li>\n\t<li><code>enQueue(value)</code>: Insert an element into the circular queue. Return true if the operation is successful.</li>\n\t<li><code>deQueue()</code>: Delete an element from the circular queue. Return true if the operation is successful.</li>\n\t<li><code>isEmpty()</code>: Checks whether the circular queue is empty or not.</li>\n\t<li><code>isFull()</code>: Checks whether the circular queue is full or not.</li>\n</ul>\n<p>&nbsp;</p>\n<p><strong>Example:</strong></p>\n<pre>\nMyCircularQueue circularQueue = new MyCircularQueue(3); // set the size to be 3\ncircularQueue.enQueue(1); &nbsp;// return true\ncircularQueue.enQueue(2); &nbsp;// return true\ncircularQueue.enQueue(3); &nbsp;// return true\ncircularQueue.enQueue(4); &nbsp;// return false, the queue is full\ncircularQueue.Rear(); &nbsp;// return 3\ncircularQueue.isFull(); &nbsp;// return true\ncircularQueue.deQueue(); &nbsp;// return true\ncircularQueue.enQueue(4); &nbsp;// return true\ncircularQueue.Rear(); &nbsp;// return 4\n</pre>\n<p> </p>\n<p><strong>Note:</strong></p>\n<ul>\n\t<li>All values will be in the range of [0, 1000].</li>\n\t<li>The number of operations will be in the range of&nbsp;[1, 1000].</li>\n\t<li>Please do not use the built-in Queue library.</li>\n</ul>","frontmatter":{"title":"Design Circular Queue","timeSpent":50,"qId":860,"date":"2020-05-26","conquered":false,"wrongTime":0,"withHelp":false}}},{"node":{"fields":{"slug":"/learn/array-101/conclusion/find-all-numbers-disappeared-in-an-array/"},"html":"<h2>findDisappearedNumbers (50 mins)</h2>\n<h3>Question：</h3>\n<h5>Description:</h5>\n<ul>\n<li>Given an array of integers where 1 ≤ a[i] ≤ n (n = size of array), some elements appear twice and others appear once.</li>\n<li>Find all the elements of [1, n] inclusive that do not appear in this array.</li>\n<li>Could you do it without extra space and in O(n) runtime? You may assume the returned list does not count as extra space.</li>\n</ul>\n<h5>Note:</h5>\n<ul>\n<li>placeholder</li>\n</ul>\n<h5>Examples:</h5>\n<pre><code>Input:\n[4,3,2,7,8,2,3,1]\n\nOutput:\n[5,6]\n</code></pre>\n<h3>Process:</h3>\n<ul>\n<li><a href=\"https://www.youtube.com/watch?v=efU_3Da3DV0\">https://www.youtube.com/watch?v=efU_3Da3DV0</a> 看了这个老哥的，把我惊呆了，直接用了一个dict。。。</li>\n<li>当然我一开始题目意思理解错了，without extra space, returned list 也是可以直接用的。</li>\n</ul>\n<h3>Answer:</h3>\n<h3>Others Answer:</h3>","frontmatter":{"title":"findDisappearedNumbers","timeSpent":50,"qId":null,"date":"2020-05-10","conquered":null,"wrongTime":null,"withHelp":null}}},{"node":{"fields":{"slug":"/learn/array-101/conclusion/third-maximum-number/"},"html":"<h2>Third Maximum Number (10 mins)</h2>\n<h3>Question：</h3>\n<h5>Description:</h5>\n<ul>\n<li>Given a non-empty array of integers, return the third maximum number in this array. If it does not exist, return the maximum number. The time complexity must be in O(n).</li>\n</ul>\n<h5>Note:</h5>\n<ul>\n<li>placeholder</li>\n</ul>\n<h5>Examples:</h5>\n<pre><code>Input: [3, 2, 1]\n\nOutput: 1\n\nExplanation: The third maximum is 1.\n\nInput: [1, 2]\n\nOutput: 2\n\nExplanation: The third maximum does not exist, so the maximum (2) is returned instead.\n\nInput: [2, 2, 3, 1]\n\nOutput: 1\n\nExplanation: Note that the third maximum here means the third maximum distinct number.\nBoth numbers with value 2 are both considered as second maximum.\n</code></pre>\n<h3>Process:</h3>\n<ul>\n<li>placeholder</li>\n</ul>\n<h3>Answer:</h3>\n<h3>Others Answer:</h3>","frontmatter":{"title":"Third Maximum Number","timeSpent":10,"qId":null,"date":"2020-05-10","conquered":null,"wrongTime":null,"withHelp":null}}},{"node":{"fields":{"slug":"/learn/array-101/conclusion/height-checker/"},"html":"<h2>Height Checker (10 mins)</h2>\n<h3>Question：</h3>\n<h5>Description:</h5>\n<ul>\n<li>Students are asked to stand in non-decreasing order of heights for an annual photo.</li>\n<li>Return the minimum number of students that must move in order for all students to be standing in non-decreasing order of height.</li>\n<li>Notice that when a group of students is selected they can reorder in any possible way between themselves and the non selected students remain on their seats.</li>\n</ul>\n<h5>Constraints:</h5>\n<ul>\n<li>1 &#x3C;= heights.length &#x3C;= 100</li>\n<li>1 &#x3C;= heights[i] &#x3C;= 100</li>\n</ul>\n<h5>Examples:</h5>\n<pre><code>Input: heights = [1,1,4,2,1,3]\nOutput: 3\nExplanation:\nCurrent array : [1,1,4,2,1,3]\nTarget array  : [1,1,1,2,3,4]\nOn index 2 (0-based) we have 4 vs 1 so we have to move this student.\nOn index 4 (0-based) we have 1 vs 3 so we have to move this student.\nOn index 5 (0-based) we have 3 vs 4 so we have to move this student.\n\nInput: heights = [5,1,2,3,4]\nOutput: 5\n\nInput: heights = [1,2,3,4,5]\nOutput: 0\n</code></pre>\n<h3>Process:</h3>\n<ul>\n<li>\n<p>这道题主要是理解题意</p>\n<ul>\n<li>哪些学生是不要懂的</li>\n</ul>\n</li>\n<li>一个排序一个对比</li>\n<li>一个insertion sort 就可以走天下了</li>\n</ul>\n<h3>Answer:</h3>\n<h3>Others Answer:</h3>","frontmatter":{"title":"Height Checker","timeSpent":10,"qId":null,"date":"2020-05-09","conquered":null,"wrongTime":null,"withHelp":null}}},{"node":{"fields":{"slug":"/learn/array-101/in-place-operations/replace-elements-with-greatest-element-on-right-side/"},"html":"<h2>Replace Elements with Greatest Element on Right Side ( mins)</h2>\n<h3>Question：</h3>\n<h5>Description:</h5>\n<ul>\n<li>Given an array arr, replace every element in that array with the greatest element among the elements to its right, and replace the last element with -1.</li>\n<li>After doing so, return the array.</li>\n</ul>\n<h5>Note:</h5>\n<ul>\n<li>1 &#x3C;= arr.length &#x3C;= 10^4</li>\n<li>1 &#x3C;= arr[i] &#x3C;= 10^5</li>\n</ul>\n<h5>Examples:</h5>\n<pre><code>Input: arr = [17,18,5,4,6,1]\nOutput: [18,6,6,6,1,-1]\n</code></pre>\n<h3>Process:</h3>\n<ul>\n<li>\n<p>看了几遍才看懂， 是真的好几遍。。。</p>\n<ul>\n<li>对每一个元素 都用它右边的最大的元素替代</li>\n</ul>\n</li>\n<li>典型的O(n^2)</li>\n</ul>\n<h3>Answer:</h3>\n<h3>Others Answer:</h3>","frontmatter":{"title":"Replace Elements with Greatest Element on Right Side","timeSpent":0,"qId":null,"date":"2020-05-09","conquered":null,"wrongTime":null,"withHelp":null}}},{"node":{"fields":{"slug":"/learn/array-101/in-place-operations/sort-array-by-parity/"},"html":"<h2>Sort Array By Parity (20 mins)</h2>\n<h3>Question：</h3>\n<h5>Description:</h5>\n<ul>\n<li>Given an array A of non-negative integers, return an array consisting of all the even elements of A, followed by all the odd elements of A.</li>\n<li>You may return any answer array that satisfies this condition.</li>\n</ul>\n<h5>Note:</h5>\n<ul>\n<li>1 &#x3C;= A.length &#x3C;= 5000</li>\n<li>0 &#x3C;= A[i] &#x3C;= 5000</li>\n</ul>\n<h5>Examples:</h5>\n<pre><code>Input: [3,1,2,4]\nOutput: [2,4,3,1]\nThe outputs [4,2,3,1], [2,4,1,3], and [4,2,1,3] would also be accepted.\n</code></pre>\n<h3>Process:</h3>\n<ul>\n<li>\n<p>we need two pointer</p>\n<ul>\n<li>one to do the main loop</li>\n<li>the other is to records the position of the end of the element in origin array</li>\n</ul>\n</li>\n</ul>\n<h3>Answer:</h3>\n<h3>Others Answer:</h3>","frontmatter":{"title":"Sort Array By Parity","timeSpent":20,"qId":null,"date":"2020-05-09","conquered":null,"wrongTime":null,"withHelp":null}}},{"node":{"fields":{"slug":"/learn/array-101/in-place-operations/squares-of-a-sorted-array/"},"html":"<h2>Squares of a Sorted Array (40 mins)</h2>\n<h3>Question：</h3>\n<h5>Description:</h5>\n<ul>\n<li>Given an array of integers A sorted in non-decreasing order, return an array of the squares of each number, also in sorted non-decreasing order.</li>\n</ul>\n<h5>Note:</h5>\n<ul>\n<li>1 &#x3C;= A.length &#x3C;= 10000</li>\n<li>-10000 &#x3C;= A[i] &#x3C;= 10000</li>\n<li>A is sorted in non-decreasing order.</li>\n</ul>\n<h5>Examples:</h5>\n<pre><code>Input: [-4,-1,0,3,10]\nOutput: [0,1,9,16,100]\n\nInput: [-7,-3,2,3,11]\nOutput: [4,9,9,49,121]\n</code></pre>\n<h3>Process:</h3>\n<ul>\n<li>\n<p>找到交界点，0左边的元素的边界i</p>\n<ul>\n<li>所有的都平方，然后把刚刚i左边的元素都插到右边</li>\n<li>一开始想是想这么做的，后来自己太菜了，所以直接平方后，排序好了</li>\n</ul>\n</li>\n</ul>\n<h3>Answer:</h3>\n<h3>Others Answer:</h3>","frontmatter":{"title":"Squares of a Sorted Array","timeSpent":40,"qId":null,"date":"2020-05-09","conquered":null,"wrongTime":null,"withHelp":null}}},{"node":{"fields":{"slug":"/learn/array-101/searching-for-items-in-an-array/check-if-n-and-its-double-exist/"},"html":"<h2>Check If N and Its Double Exist ( mins)</h2>\n<h3>Question：</h3>\n<h5>Description:</h5>\n<ul>\n<li>Given an array arr of integers, check if there exists two integers N and M such that N is the double of M ( i.e. N = 2 * M).</li>\n<li>\n<p>More formally check if there exists two indices i and j such that :</p>\n<ul>\n<li>i != j</li>\n<li>0 &#x3C;= i, j &#x3C; arr.length</li>\n<li>arr[i] == 2 * arr[j]</li>\n</ul>\n</li>\n</ul>\n<h5>Constraints:</h5>\n<ul>\n<li>2 &#x3C;= arr.length &#x3C;= 500</li>\n<li>-10^3 &#x3C;= arr[i] &#x3C;= 10^3</li>\n</ul>\n<h5>Examples:</h5>\n<pre><code>Input: arr = [10,2,5,3]\nOutput: true\nExplanation: N = 10 is the double of M = 5,that is, 10 = 2 * 5.\n\nInput: arr = [7,1,14,11]\nOutput: true\nExplanation: N = 14 is the double of M = 7,that is, 14 = 2 * 7.\n\nInput: arr = [3,1,7,11]\nOutput: false\nExplanation: In this case does not exist N and M, such that N = 2 * M.\n</code></pre>\n<h3>Process:</h3>\n<ul>\n<li>placeholder</li>\n</ul>\n<h3>Answer:</h3>\n<h3>Others Answer:</h3>","frontmatter":{"title":"Check If N and Its Double Exist","timeSpent":0,"qId":null,"date":"2020-05-09","conquered":null,"wrongTime":null,"withHelp":null}}},{"node":{"fields":{"slug":"/learn/array-101/searching-for-items-in-an-array/valid-mountain-array/"},"html":"<h2>validMountainArray (10 mins)</h2>\n<h3>Question：</h3>\n<h5>Description:</h5>\n<ul>\n<li>Given an array A of integers, return true if and only if it is a valid mountain array.</li>\n<li>\n<p>Recall that A is a mountain array if and only if:</p>\n<ul>\n<li>A.length >= 3</li>\n<li>There exists some i with 0 &#x3C; i &#x3C; A.length - 1 such that:</li>\n<li>A[0] &#x3C; A[1] &#x3C; ... A[i-1] &#x3C; A[i]</li>\n<li>A[i] > A[i+1] > ... > A[A.length - 1]</li>\n</ul>\n</li>\n<li><img src=\"https://assets.leetcode.com/uploads/2019/10/20/hint_valid_mountain_array.png\" alt=\"hint-valid-array\"></li>\n</ul>\n<h5>Note:</h5>\n<ul>\n<li>0 &#x3C;= A.length &#x3C;= 10000</li>\n<li>0 &#x3C;= A[i] &#x3C;= 10000</li>\n</ul>\n<h5>Examples:</h5>\n<pre><code>Input: [2,1]\nOutput: false\n\nInput: [3,5,5]\nOutput: false\n\nInput: [0,3,2,1]\nOutput: true\n</code></pre>\n<h3>Process:</h3>\n<ul>\n<li>找唯一的最大值</li>\n<li>线性查找</li>\n<li>不对不对，这个mountain要求连续上升，然后下降</li>\n<li>其实可以直接从定义出发，找到N个转折点，转折点超过2就挂了，或者有两个连续相等的值</li>\n</ul>\n<h3>Answer:</h3>\n<h3>Others Answer:</h3>","frontmatter":{"title":"validMountainArray","timeSpent":10,"qId":null,"date":"2020-05-09","conquered":null,"wrongTime":null,"withHelp":null}}},{"node":{"fields":{"slug":"/learn/array-101/inserting-items-into-an-array/duplicate-zeros/"},"html":"<h2>Duplicate Zeros ( mins)</h2>\n<h3>Question：</h3>\n<h5>Description:</h5>\n<ul>\n<li>Given a fixed length array arr of integers, duplicate each occurrence of zero, shifting the remaining elements to the right.</li>\n<li>Note that elements beyond the length of the original array are not written.</li>\n<li>Do the above modifications to the input array in place, do not return anything from your function.</li>\n</ul>\n<h5>Note:</h5>\n<ul>\n<li>1 &#x3C;= arr.length &#x3C;= 10000</li>\n<li>0 &#x3C;= arr[i] &#x3C;= 9</li>\n</ul>\n<h5>Examples:</h5>\n<pre><code>Input: [1,0,2,3,0,4,5,0]\nOutput: null\nExplanation: After calling your function, the input array is modified to: [1,0,0,2,3,0,0,4]\n\nInput: [1,2,3]\nOutput: null\nExplanation: After calling your function, the input array is modified to: [1,2,3]\n</code></pre>\n<h3>Process:</h3>\n<ul>\n<li>placeholder</li>\n</ul>\n<h3>Answer:</h3>\n<h3>Others Answer:</h3>","frontmatter":{"title":"Duplicate Zeros","timeSpent":0,"qId":null,"date":"2020-05-08","conquered":null,"wrongTime":null,"withHelp":null}}},{"node":{"fields":{"slug":"/learn/array-101/inserting-items-into-an-array/merge-sorted-array/"},"html":"<h2>Merge Sorted Array ( mins)</h2>\n<h3>Question：</h3>\n<h5>Description:</h5>\n<ul>\n<li>Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array.</li>\n</ul>\n<h5>Note:</h5>\n<ul>\n<li>The number of elements initialized in nums1 and nums2 are m and n respectively.</li>\n<li>You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2.</li>\n</ul>\n<h5>Examples:</h5>\n<pre><code>Input:\nnums1 = [1,2,3,0,0,0], m = 3\nnums2 = [2,5,6],       n = 3\n\nOutput: [1,2,2,3,5,6]\n</code></pre>\n<h3>Process:</h3>\n<ul>\n<li>做题目全靠猜，全靠直接执行测试</li>\n</ul>\n<h3>Answer:</h3>\n<h3>Others Answer:</h3>","frontmatter":{"title":"Merge Sorted Array","timeSpent":0,"qId":null,"date":"2020-05-08","conquered":null,"wrongTime":null,"withHelp":null}}},{"node":{"fields":{"slug":"/learn/array-101/introduction/find-numbers-with-even-number-of-digits/"},"html":"<h2>Find Numbers with Even Number of Digits ( mins)</h2>\n<h3>Question：</h3>\n<h5>Description:</h5>\n<ul>\n<li>Given an array nums of integers, return how many of them contain an even number of digits.</li>\n</ul>\n<h5>Examples:</h5>\n<pre><code>Input: nums = [12,345,2,6,7896]\nOutput: 2\nExplanation:\n12 contains 2 digits (even number of digits).\n345 contains 3 digits (odd number of digits).\n2 contains 1 digit (odd number of digits).\n6 contains 1 digit (odd number of digits).\n7896 contains 4 digits (even number of digits).\nTherefore only 12 and 7896 contain an even number of digits.\n\nInput: nums = [555,901,482,1771]\nOutput: 1\nExplanation:\nOnly 1771 contains an even number of digits.\n</code></pre>\n<h5>Constraints:</h5>\n<ul>\n<li>1 &#x3C;= nums.length &#x3C;= 500</li>\n<li>1 &#x3C;= nums[i] &#x3C;= 10^5</li>\n</ul>\n<h3>Process:</h3>\n<ul>\n<li>placeholder</li>\n</ul>\n<h3>Answer:</h3>\n<h3>Others Answer:</h3>","frontmatter":{"title":"Find Numbers with Even Number of Digits","timeSpent":0,"qId":null,"date":"2020-05-08","conquered":null,"wrongTime":null,"withHelp":null}}},{"node":{"fields":{"slug":"/learn/array-101/introduction/squares-of-a-sorted-array/"},"html":"<h2>Squares of a Sorted Array ( mins)</h2>\n<h3>Question：</h3>\n<h5>Description:</h5>\n<ul>\n<li>Given an array of integers A sorted in non-decreasing order, return an array of the squares of each number, also in sorted non-decreasing order.</li>\n</ul>\n<h5>Note:</h5>\n<ul>\n<li>1 &#x3C;= A.length &#x3C;= 10000</li>\n<li>-10000 &#x3C;= A[i] &#x3C;= 10000</li>\n<li>A is sorted in non-decreasing order.</li>\n</ul>\n<h5>Examples:</h5>\n<pre><code>Input: [-4,-1,0,3,10]\nOutput: [0,1,9,16,100]\n\nInput: [-7,-3,2,3,11]\nOutput: [4,9,9,49,121]\n</code></pre>\n<h3>Process:</h3>\n<ul>\n<li>\n<p>先做一次排序吧，如果这样的话 一开始给到的条件就没什么用了</p>\n<ul>\n<li>要想有用，可以做半个排序，也就是只负责把 &#x3C; 0 的部分插入到右边</li>\n</ul>\n</li>\n</ul>\n<h3>Answer:</h3>\n<h3>Others Answer:</h3>","frontmatter":{"title":"Squares of a Sorted Array","timeSpent":0,"qId":null,"date":"2020-05-08","conquered":null,"wrongTime":null,"withHelp":null}}},{"node":{"fields":{"slug":"/learn/array-and-string/conclusion/move-zeroes/"},"html":"<h2>Move Zeroes ( mins)</h2>\n<h3>Question：</h3>\n<h5>Description:</h5>\n<ul>\n<li>Given an array nums, write a function to move all 0's to the end of it while maintaining the relative order of the non-zero elements.</li>\n</ul>\n<h5>Note:</h5>\n<ul>\n<li>You must do this in-place without making a copy of the array.</li>\n<li>Minimize the total number of operations.</li>\n</ul>\n<h5>Examples:</h5>\n<pre><code>Input: [0,1,0,3,12]\nOutput: [1,3,12,0,0]\n</code></pre>\n<h3>Process:</h3>\n<ul>\n<li>placeholder</li>\n</ul>\n<h3>Answer:</h3>\n<h3>Others Answer:</h3>","frontmatter":{"title":"Move Zeroes","timeSpent":0,"qId":null,"date":"2020-05-07","conquered":null,"wrongTime":null,"withHelp":null}}},{"node":{"fields":{"slug":"/learn/array-and-string/conclusion/pascals-triangle-2/"},"html":"<h2>Pascal's Triangle II ( mins)</h2>\n<h3>Question：</h3>\n<h5>Description:</h5>\n<ul>\n<li>Given a non-negative index k where k ≤ 33, return the kth index row of the Pascal's triangle.</li>\n<li>Note that the row index starts from 0.</li>\n</ul>\n<h5>Note:</h5>\n<ul>\n<li>placeholder</li>\n</ul>\n<h5>Examples:</h5>\n<pre><code>Input: 3\nOutput: [1,3,3,1]\n</code></pre>\n<h3>Process:</h3>\n<ul>\n<li>不知道怎么去更好的优化它</li>\n<li>写的时候走点心，用点脑子，别想着老是debug，要人脑debug</li>\n</ul>\n<h3>Answer:</h3>\n<h3>Others Answer:</h3>","frontmatter":{"title":"Pascal's Triangle II","timeSpent":0,"qId":null,"date":"2020-05-07","conquered":null,"wrongTime":null,"withHelp":null}}},{"node":{"fields":{"slug":"/learn/array-and-string/conclusion/remove-duplicates-from-sorted-array/"},"html":"<h2>Remove Duplicates from Sorted Array (15 mins)</h2>\n<h3>Question：</h3>\n<h5>Description:</h5>\n<ul>\n<li>Given a sorted array nums, remove the duplicates in-place such that each element appear only once and return the new length.</li>\n<li>Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.</li>\n</ul>\n<h5>Clarification:</h5>\n<ul>\n<li>Confused why the returned value is an integer but your answer is an array?</li>\n<li>Note that the input array is passed in by reference, which means modification to the input array will be known to the caller as well.</li>\n<li>\n<p>Internally you can think of this:</p>\n<pre><code>// nums is passed in by reference. (i.e., without making a copy)\nint len = removeDuplicates(nums);\n</code></pre>\n</li>\n</ul>\n<p>// any modification to nums in your function would be known by the caller.\n// using the length returned by your function, it prints the first len elements.\nfor (int i = 0; i &#x3C; len; i++) {\nprint(nums[i]);\n}</p>\n<pre><code>##### Examples:\n</code></pre>\n<p>Given nums = [1,1,2],</p>\n<p>Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively.</p>\n<p>It doesn't matter what you leave beyond the returned length.</p>\n<p>Given nums = [0,0,1,1,1,2,2,3,3,4],</p>\n<p>Your function should return length = 5, with the first five elements of nums being modified to 0, 1, 2, 3, and 4 respectively.</p>\n<p>It doesn't matter what values are set beyond the returned length.</p>\n<pre><code>### Process:\n- 说说直觉\n  - sorted array 第一感觉就是binary search\n\n### Answer:\n\n### Others Answer:\n</code></pre>","frontmatter":{"title":"Remove Duplicates from Sorted Array","timeSpent":15,"qId":null,"date":"2020-05-07","conquered":null,"wrongTime":null,"withHelp":null}}},{"node":{"fields":{"slug":"/learn/array-and-string/conclusion/reverse-words-in-a-string/"},"html":"<h2>Reverse Words in a String ( mins)</h2>\n<h3>Question：</h3>\n<h5>Description:</h5>\n<ul>\n<li>Given an input string, reverse the string word by word.</li>\n</ul>\n<h5>Note:</h5>\n<ul>\n<li>A word is defined as a sequence of non-space characters.</li>\n<li>Input string may contain leading or trailing spaces. However, your reversed string should not contain leading or trailing spaces.</li>\n<li>You need to reduce multiple spaces between two words to a single space in the reversed string.</li>\n</ul>\n<h5>Examples:</h5>\n<pre><code>Input: \"the sky is blue\"\nOutput: \"blue is sky the\"\n\nInput: \"  hello world!  \"\nOutput: \"world! hello\"\nExplanation: Your reversed string should not contain leading or trailing spaces.\n\nInput: \"a good   example\"\nOutput: \"example good a\"\nExplanation: You need to reduce multiple spaces between two words to a single space in the reversed string.\n</code></pre>\n<h3>Process:</h3>\n<ul>\n<li>从尾部开始迭代，两个索引指针（快慢）</li>\n</ul>\n<h3>Answer:</h3>\n<h3>Others Answer:</h3>","frontmatter":{"title":"Reverse Words in a String","timeSpent":0,"qId":null,"date":"2020-05-07","conquered":null,"wrongTime":null,"withHelp":null}}},{"node":{"fields":{"slug":"/learn/array-and-string/conclusion/reverse-words-in-a-string-3/"},"html":"<h2>Reverse Words in a String III ( mins)</h2>\n<h3>Question：</h3>\n<h5>Description:</h5>\n<ul>\n<li>Given a string, you need to reverse the order of characters in each word within a sentence while still preserving whitespace and initial word order.</li>\n</ul>\n<h5>Note:</h5>\n<ul>\n<li>In the string, each word is separated by single space and there will not be any extra space in the string.</li>\n</ul>\n<h5>Examples:</h5>\n<pre><code>Input: \"Let's take LeetCode contest\"\nOutput: \"s'teL ekat edoCteeL tsetnoc\"\n</code></pre>\n<h3>Process:</h3>\n<ul>\n<li>placeholder</li>\n</ul>\n<h3>Answer:</h3>\n<h3>Others Answer:</h3>","frontmatter":{"title":"Reverse Words in a String III","timeSpent":0,"qId":null,"date":"2020-05-07","conquered":null,"wrongTime":null,"withHelp":null}}},{"node":{"fields":{"slug":"/learn/array-and-string/conclusion/rotate-array/"},"html":"<h2>Rotate Array (60 mins)</h2>\n<h3>Question：</h3>\n<h5>Description:</h5>\n<ul>\n<li>Given an array, rotate the array to the right by k steps, where k is non-negative.</li>\n</ul>\n<h5>Note:</h5>\n<ul>\n<li>\n<p>Follow up:</p>\n<ul>\n<li>Try to come up as many solutions as you can, there are at least 3 different ways to solve this problem.</li>\n<li>Could you do it in-place with O(1) extra space?</li>\n</ul>\n</li>\n</ul>\n<h5>Examples:</h5>\n<pre><code>Input: nums = [1,2,3,4,5,6,7], k = 3\nOutput: [5,6,7,1,2,3,4]\nExplanation:\nrotate 1 steps to the right: [7,1,2,3,4,5,6]\nrotate 2 steps to the right: [6,7,1,2,3,4,5]\nrotate 3 steps to the right: [5,6,7,1,2,3,4]\n\nInput: nums = [-1,-100,3,99], k = 2\nOutput: [3,99,-1,-100]\nExplanation:\nrotate 1 steps to the right: [99,-1,-100,3]\nrotate 2 steps to the right: [3,99,-1,-100]\n</code></pre>\n<h5>Constraints:</h5>\n<ul>\n<li>1 &#x3C;= nums.length &#x3C;= 2 * 10^4</li>\n<li>It's guaranteed that nums[i] fits in a 32 bit-signed integer.</li>\n<li>k >= 0</li>\n</ul>\n<h3>Process:</h3>\n<ul>\n<li>placeholder</li>\n</ul>\n<h3>Answer:</h3>\n<h3>Others Answer:</h3>","frontmatter":{"title":"Rotate Array","timeSpent":60,"qId":null,"date":"2020-05-06","conquered":null,"wrongTime":null,"withHelp":null}}},{"node":{"fields":{"slug":"/learn/array-and-string/array-two-pointer-technique/max-consecutive-ones/"},"html":"<h2>Max Consecutive Ones (20 mins)</h2>\n<h3>Question：</h3>\n<h5>Description:</h5>\n<ul>\n<li>Given a binary array, find the maximum number of consecutive 1s in this array.</li>\n</ul>\n<h5>Note:</h5>\n<ul>\n<li>The input array will only contain 0 and 1.</li>\n<li>The length of input array is a positive integer and will not exceed 10,000</li>\n</ul>\n<h5>Examples:</h5>\n<pre><code>Input: [1,1,0,1,1,1]\nOutput: 3\nExplanation: The first two digits or the last three digits are consecutive 1s.\n    The maximum number of consecutive 1s is 3.\n</code></pre>\n<h3>Process:</h3>\n<ul>\n<li>\n<p>one for outer iteration</p>\n<ul>\n<li>one for inner loop</li>\n</ul>\n</li>\n</ul>\n<h3>Answer:</h3>\n<h3>Others Answer:</h3>","frontmatter":{"title":"Max Consecutive Ones","timeSpent":20,"qId":485,"date":"2020-04-30","conquered":null,"wrongTime":null,"withHelp":null}}},{"node":{"fields":{"slug":"/learn/array-and-string/array-two-pointer-technique/minimum-size-subarray-sum/"},"html":"<h2>Minimum Size Subarray Sum ( mins)</h2>\n<h3>Question：</h3>\n<h5>Description:</h5>\n<ul>\n<li>Given an array of n positive integers and a positive integer s, find the minimal length of a contiguous subarray of which the sum ≥ s. If there isn't one, return 0 instead.</li>\n</ul>\n<h5>Note:</h5>\n<ul>\n<li>If you have figured out the O(n) solution, try coding another solution of which the time complexity is O(n log n).</li>\n</ul>\n<h5>Examples:</h5>\n<pre><code>Input: s = 7, nums = [2,3,1,2,4,3]\nOutput: 2\nExplanation: the subarray [4,3] has the minimal length under the problem constraint.\n</code></pre>\n<h3>Process:</h3>\n<ul>\n<li>O(n ^ 3) 挂了</li>\n<li>思考思考数学问题，因为算法很多时候跟数学问题息息相关</li>\n<li>\n<p>看了题解</p>\n<ul>\n<li>有点神奇</li>\n<li>总结一下：</li>\n<li>利用的一点就是 迭代累加，如果加上这个<strong>刚好</strong>大于等于s，那么子数组一定是包含当前元素的。</li>\n<li>然后从子数组签名剔除元素，直到不再 >= s</li>\n</ul>\n</li>\n</ul>\n<h3>Answer:</h3>\n<h3>Others Answer:</h3>","frontmatter":{"title":"Minimum Size Subarray Sum","timeSpent":100,"qId":null,"date":"2020-04-30","conquered":null,"wrongTime":null,"withHelp":null}}},{"node":{"fields":{"slug":"/learn/array-and-string/array-two-pointer-technique/remove-element/"},"html":"<h2>Remove Element ( mins)</h2>\n<h3>Question：</h3>\n<h5>Description:</h5>\n<ul>\n<li>Given an array nums and a value val, remove all instances of that value <strong>in-place</strong> and return the new length.</li>\n<li>Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.</li>\n<li>The order of elements can be changed. It doesn't matter what you leave beyond the new length.</li>\n</ul>\n<h5>Clarification:</h5>\n<ul>\n<li>Confused why the returned value is an integer but your answer is an array?</li>\n<li>Note that the input array is passed in by reference, which means modification to the input array will be known to the caller as well.</li>\n<li>\n<p>Internally you can think of this:</p>\n<pre><code>// nums is passed in by reference. (i.e., without making a copy)\nint len = removeElement(nums, val);\n\n// any modification to nums in your function would be known by the caller.\n// using the length returned by your function, it prints the first len elements.\nfor (int i = 0; i &#x3C; len; i++) {\n  print(nums[i]);\n}\n</code></pre>\n</li>\n</ul>\n<h5>Examples:</h5>\n<pre><code>Given nums = [3,2,2,3], val = 3,\n\n// Your function should return length = 2, with the first two elements of nums being 2.\n\n// It doesn't matter what you leave beyond the returned length.\n\nGiven nums = [0,1,2,2,3,0,4,2], val = 2,\n\nYour function should return length = 5, with the first five elements of nums containing 0, 1, 3, 0, and 4.\n\nNote that the order of those five elements can be arbitrary.\n\nIt doesn't matter what values are set beyond the returned length.\n</code></pre>\n<h3>Process:</h3>\n<ul>\n<li>So stupid question description...</li>\n<li>just modify the input array and return the length</li>\n<li>\n<p>use two pointer</p>\n<ul>\n<li>one for iteration</li>\n<li>one be placed in the end (always keep elements after second pointer is the target val)</li>\n<li>if current iteration value if the target value, just swap it with second pointer</li>\n</ul>\n</li>\n<li>\n<p>实际做的时候还是遇到了一些问题了，这道题一共卡了80分钟。。。本来状态就不好，\n其中有一个判断条件是 右边指针--，需要一个while循环去减减，这样才服务和哦我们的想法</p>\n<ul>\n<li>右边的指针代表：下一个要被替换的元素，在他右边的都是 === val的</li>\n</ul>\n</li>\n</ul>\n<h3>Answer:</h3>\n<h3>Others Answer:</h3>","frontmatter":{"title":"Remove Element","timeSpent":80,"qId":null,"date":"2020-04-30","conquered":null,"wrongTime":null,"withHelp":null}}},{"node":{"fields":{"slug":"/learn/array-and-string/array-two-pointer-technique/reverse-string/"},"html":"<h2>Reverse String (6 mins)</h2>\n<h3>Question：</h3>\n<h5>Description:</h5>\n<ul>\n<li>Write a function that reverses a string. The input string is given as an array of characters char[].</li>\n<li>Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.</li>\n<li>You may assume all the characters consist of printable ascii characters.</li>\n</ul>\n<h5>Note:</h5>\n<ul>\n<li>placeholder</li>\n</ul>\n<h5>Examples:</h5>\n<pre><code>Input: [\"h\",\"e\",\"l\",\"l\",\"o\"]\nOutput: [\"o\",\"l\",\"l\",\"e\",\"h\"]\n\nInput: [\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"]\nOutput: [\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"]\n</code></pre>\n<h3>Process:</h3>\n<ul>\n<li>如题</li>\n</ul>\n<h3>Answer:</h3>\n<h3>Others Answer:</h3>","frontmatter":{"title":"Reverse String","timeSpent":null,"qId":null,"date":"2020-04-29","conquered":null,"wrongTime":null,"withHelp":null}}},{"node":{"fields":{"slug":"/learn/array-and-string/array-two-pointer-technique/two-sum-2-input-array-sorted/"},"html":"<h2>twoSum (20 mins)</h2>\n<h3>Question：</h3>\n<h5>Description:</h5>\n<ul>\n<li>Given an array of integers that is already sorted in ascending order, find two numbers such that they add up to a specific target number.</li>\n<li>The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2.</li>\n</ul>\n<h5>Note:</h5>\n<ul>\n<li>Your returned answers (both index1 and index2) are not zero-based.</li>\n<li>You may assume that each input would have exactly one solution and you may not use the same element twice.</li>\n</ul>\n<h5>Examples:</h5>\n<pre><code>Input: numbers = [2,7,11,15], target = 9\nOutput: [1,2]\nExplanation: The sum of 2 and 7 is 9. Therefore index1 = 1, index2 = 2.\n</code></pre>\n<h3>Process:</h3>\n<ul>\n<li>there is no assumption that the number is position so that we can filter some elements larger than target</li>\n<li>keep in mind that we should use two pointer technique</li>\n<li>\n<p>In the out loop, we can fix one number and calc the rest number by substract from target.</p>\n<ul>\n<li>use another pointer to check</li>\n</ul>\n</li>\n<li>complexity is O(n^2) i think</li>\n</ul>\n<h3>Answer:</h3>\n<h3>Others Answer:</h3>","frontmatter":{"title":"Two Sum II - Input array is sorted","timeSpent":0,"qId":null,"date":"2020-04-29","conquered":null,"wrongTime":null,"withHelp":null}}},{"node":{"fields":{"slug":"/learn/array-and-string/array-two-pointer-technique/array-partition-1/"},"html":"<h2>Array Partition I ( mins)</h2>\n<h3>Question：</h3>\n<h5>Description:</h5>\n<ul>\n<li>Given an array of 2n integers, your task is to group these integers into n pairs of integer, say (a1, b1), (a2, b2), ..., (an, bn) which makes sum of min(ai, bi) for all i from 1 to n as large as possible.</li>\n</ul>\n<h5>Note:</h5>\n<ul>\n<li>n is a positive integer, which is in the range of [1, 10000].</li>\n<li>All the integers in the array will be in the range of [-10000, 10000].</li>\n</ul>\n<h5>Examples:</h5>\n<pre><code>Input: [1,4,3,2]\n\nOutput: 4\nExplanation: n is 2, and the maximum sum of pairs is 4 = min(1, 2) + min(3, 4).\n</code></pre>\n<h3>Process:</h3>\n<ul>\n<li>we need a sort algorithm to sort the array</li>\n<li>then we just calc the sum of array skipping the even index</li>\n<li>use two pointer tech to remove the complexity.</li>\n</ul>\n<h3>Answer:</h3>\n<h3>Others Answer:</h3>","frontmatter":{"title":"Array Partition I","timeSpent":13,"qId":null,"date":"2020-04-29","conquered":null,"wrongTime":null,"withHelp":null}}},{"node":{"fields":{"slug":"/learn/array-and-string/introduction-to-string/add-binary/"},"html":"<h2>Add Binary (25 mins)</h2>\n<h3>Question：</h3>\n<h5>Description:</h5>\n<ul>\n<li>Given two binary strings, return their sum (also a binary string).</li>\n<li>The input strings are both non-empty and contains only characters 1 or 0.</li>\n</ul>\n<h5>Constraints:</h5>\n<ul>\n<li>Each string consists only of '0' or '1' characters.</li>\n<li>1 &#x3C;= a.length, b.length &#x3C;= 10^4</li>\n<li>Each string is either \"0\" or doesn't contain any leading zero.</li>\n</ul>\n<h5>Examples:</h5>\n<pre><code>Input: a = \"11\", b = \"1\"\nOutput: \"100\"\n\nInput: a = \"1010\", b = \"1011\"\nOutput: \"10101\"\n</code></pre>\n<h3>Process:</h3>\n<ul>\n<li>convert the input string into two arrays</li>\n<li>add digit by digit starting by the last index and index--</li>\n</ul>\n<h3>Answer:</h3>\n<h3>Others Answer:</h3>","frontmatter":{"title":"Add Binary","timeSpent":null,"qId":null,"date":"2020-04-28","conquered":null,"wrongTime":null,"withHelp":null}}},{"node":{"fields":{"slug":"/learn/array-and-string/introduction-to-string/implement-strstr-method/"},"html":"<h2>Implement strStr() (20 mins)</h2>\n<h3>Question：</h3>\n<h5>Description:</h5>\n<ul>\n<li>Implement <a href=\"http://www.cplusplus.com/reference/cstring/strstr/\">strStr()</a>.</li>\n<li>Return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.</li>\n</ul>\n<h5>Clarification:</h5>\n<ul>\n<li>What should we return when needle is an empty string? This is a great question to ask during an interview.</li>\n<li>For the purpose of this problem, we will return 0 when needle is an empty string. This is consistent to C's strstr() and Java's indexOf().</li>\n</ul>\n<h5>Examples:</h5>\n<pre><code>Input: haystack = \"hello\", needle = \"ll\"\nOutput: 2\n\nInput: haystack = \"aaaaa\", needle = \"bba\"\nOutput: -1\n</code></pre>\n<h3>Process:</h3>\n<ul>\n<li>convert the input string into array</li>\n<li>use a simple for loop the check whether equality</li>\n<li>complexity is O(n)</li>\n</ul>\n<h3>Answer:</h3>\n<h3>Others Answer:</h3>","frontmatter":{"title":"Implement strStr()","timeSpent":null,"qId":null,"date":"2020-04-28","conquered":null,"wrongTime":null,"withHelp":null}}},{"node":{"fields":{"slug":"/learn/array-and-string/introduction-to-string/longest-common-prefix/"},"html":"<h2>Longest Common Prefix ( mins)</h2>\n<h3>Question：</h3>\n<h5>Description:</h5>\n<ul>\n<li>Write a function to find the longest common prefix string amongst an array of strings.</li>\n<li>If there is no common prefix, return an empty string \"\".</li>\n</ul>\n<h5>Note:</h5>\n<ul>\n<li>All given inputs are in lowercase letters a-z.</li>\n</ul>\n<h5>Examples:</h5>\n<pre><code>Input: [\"flower\",\"flow\",\"flight\"]\nOutput: \"fl\"\n\nInput: [\"dog\",\"racecar\",\"car\"]\nOutput: \"\"\nExplanation: There is no common prefix among the input strings.\n</code></pre>\n<h3>Process:</h3>\n<ul>\n<li>use a for loop whose index string from 0, and ++ the index</li>\n<li>if not equal, break the loop</li>\n</ul>\n<h3>Answer:</h3>\n<h3>Others Answer:</h3>","frontmatter":{"title":"Longest Common Prefix","timeSpent":null,"qId":null,"date":"2020-04-28","conquered":null,"wrongTime":null,"withHelp":null}}},{"node":{"fields":{"slug":"/learn/array-and-string/introduction-to-2d-array/diagonal-traverse/"},"html":"<h2>Diagonal Traverse (50 mins)</h2>\n<h3>Question：</h3>\n<h5>Description:</h5>\n<ul>\n<li>Given a matrix of M x N elements (M rows, N columns), return all elements of the matrix in diagonal order as shown in the below image.</li>\n</ul>\n<h5>Note:</h5>\n<ul>\n<li>placeholder</li>\n</ul>\n<h5>Examples:</h5>\n<pre><code>Input:\n[\n [ 1, 2, 3 ],\n [ 4, 5, 6 ],\n [ 7, 8, 9 ]\n]\n\nOutput:  [1,2,4,7,5,3,6,8,9]\n</code></pre>\n<h3>Process:</h3>\n<ul>\n<li>O(n^2) method</li>\n<li>calc the max(M, N)</li>\n<li>\n<p>rules (check in the boundary of array before, so that other lang except js won't throw error)</p>\n<ul>\n<li>even  (0, 0)</li>\n<li>odd (1, 0) (0, 1)</li>\n<li>even  (0, 2) (1, 1) (2, 0)</li>\n<li>odd (3, 0) (2, 1) (1, 2) (0, 3)</li>\n</ul>\n</li>\n</ul>\n<h3>Answer:</h3>\n<h3>Others Answer:</h3>","frontmatter":{"title":"Diagonal Traverse","timeSpent":null,"qId":null,"date":"2020-04-27","conquered":null,"wrongTime":null,"withHelp":null}}},{"node":{"fields":{"slug":"/learn/array-and-string/introduction-to-2d-array/pascal-triangle/"},"html":"<h2>Pascal's Triangle (30 mins)</h2>\n<h3>Question：</h3>\n<h5>Description:</h5>\n<ul>\n<li>Given a non-negative integer numRows, generate the first numRows of Pascal's triangle.</li>\n</ul>\n<h5>Note:</h5>\n<ul>\n<li>placeholder</li>\n</ul>\n<h5>Examples:</h5>\n<pre><code>Input: 5\nOutput:\n[\n     [1],\n    [1,1],\n   [1,2,1],\n  [1,3,3,1],\n [1,4,6,4,1]\n]\n</code></pre>\n<h3>Process:</h3>\n<ul>\n<li>\n<p>O(n^2) method</p>\n<ul>\n<li>calc each row using a nested loop</li>\n</ul>\n</li>\n<li>\n<p>more advanced method</p>\n<ul>\n<li>maybe there is a formulae</li>\n</ul>\n</li>\n</ul>\n<h3>Answer:</h3>\n<h3>Others Answer:</h3>","frontmatter":{"title":"Pascal's Triangle","timeSpent":null,"qId":null,"date":"2020-04-27","conquered":null,"wrongTime":null,"withHelp":null}}},{"node":{"fields":{"slug":"/learn/array-and-string/introduction-to-2d-array/spiral-matrix/"},"html":"<h2>Spiral Matrix (55 mins)</h2>\n<h3>Question：</h3>\n<h5>Description:</h5>\n<ul>\n<li>Given a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order.</li>\n</ul>\n<h5>Note:</h5>\n<ul>\n<li>placeholder</li>\n</ul>\n<h5>Examples:</h5>\n<pre><code>Input:\n[\n [ 1, 2, 3 ],\n [ 4, 5, 6 ],\n [ 7, 8, 9 ]\n]\nOutput: [1,2,3,6,9,8,7,4,5]\n\nInput:\n[\n  [1, 2, 3, 4],\n  [5, 6, 7, 8],\n  [9,10,11,12]\n]\nOutput: [1,2,3,4,8,12,11,10,9,5,6,7]\n</code></pre>\n<h3>Process:</h3>\n<ul>\n<li>use a variable to record direction( (0,1,2,3) % 4 ) means four direction, selfAdd if exceed the boundary</li>\n<li>use i,j to loop</li>\n<li>after seeing hints of that problems by others, a more space saving method is maybe keep track of the row/col that have been scaned.</li>\n</ul>\n<h3>Answer:</h3>\n<h3>Others Answer:</h3>","frontmatter":{"title":"Spiral Matrix","timeSpent":null,"qId":null,"date":"2020-04-27","conquered":null,"wrongTime":null,"withHelp":null}}},{"node":{"fields":{"slug":"/learn/array-and-string/introduction-to-array/find-pivot-index/"},"html":"<h2>pivotIndex (30 mins)</h2>\n<h3>Question：</h3>\n<h5>Description:</h5>\n<ul>\n<li>Given an array of integers nums, write a method that returns the \"pivot\" index of this array.</li>\n<li>We define the pivot index as the index where the sum of the numbers to the left of the index is equal to the sum of the numbers to the right of the index.</li>\n<li>If no such index exists, we should return -1. If there are multiple pivot indexes, you should return the left-most pivot index.</li>\n</ul>\n<h5>Note:</h5>\n<ul>\n<li>The length of nums will be in the range [0, 10000].</li>\n<li>Each element nums[i] will be an integer in the range [-1000, 1000].</li>\n</ul>\n<h5>Examples:</h5>\n<pre><code>Input:\nnums = [1, 7, 3, 6, 5, 6]\nOutput: 3\nExplanation:\nThe sum of the numbers to the left of index 3 (nums[3] = 6) is equal to the sum of numbers to the right of index 3.\nAlso, 3 is the first index where this occurs.\n\nInput:\nnums = [1, 2, 3]\nOutput: -1\nExplanation:\nThere is no index that satisfies the conditions in the problem statement.\n</code></pre>\n<h3>Process:</h3>\n<ul>\n<li>\n<p>O(n^2) solution(direct solution):</p>\n<ul>\n<li>iterate the given array, calc sum of numbers to the left and sum of numbers to the right</li>\n<li>if match the condition, then return it.</li>\n<li>because we iterate from left to right, so the first will be pivot</li>\n</ul>\n</li>\n<li>\n<p>O(n)</p>\n<ul>\n<li>can we record something more during loop, so that we won't calc the sum every time</li>\n<li>yes we can</li>\n<li>we need pre-calc the sum of all items in the array</li>\n<li>\n<p>then in another non-nested for-loop</p>\n<ul>\n<li>for the first item, we know the left is 0, right to current item is the sum subtract current item</li>\n<li>we store the left in an temp variable</li>\n<li>the rest item, we just need add variable and prev-item so that we can know the left sum</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3>Answer:</h3>\n<h3>Others Answer:</h3>","frontmatter":{"title":"Find Pivot Index","timeSpent":null,"qId":null,"date":"2020-04-26","conquered":null,"wrongTime":null,"withHelp":null}}},{"node":{"fields":{"slug":"/learn/array-and-string/introduction-to-array/largest-number-at-least-twice-of-others/"},"html":"<h2>Largest Number At Least Twice of Others (22 mins)</h2>\n<h3>Question：</h3>\n<h5>Description:</h5>\n<ul>\n<li>In a given integer array nums, there is always exactly one largest element.</li>\n<li>Find whether the largest element in the array is at least twice as much as every other number in the array.</li>\n<li>If it is, return the index of the largest element, otherwise return -1.</li>\n</ul>\n<h5>Note:</h5>\n<ul>\n<li>nums will have a length in the range [1, 50].</li>\n<li>Every nums[i] will be an integer in the range [0, 99].</li>\n</ul>\n<h5>Examples:</h5>\n<pre><code>Input: nums = [3, 6, 1, 0]\nOutput: 1\nExplanation: 6 is the largest integer, and for every other number in the array x,\n6 is more than twice as big as x.  The index of value 6 is 1, so we return 1.\n\nInput: nums = [1, 2, 3, 4]\nOutput: -1\nExplanation: 4 isn't at least as big as twice the value of 3, so we return -1.\n</code></pre>\n<h3>Process:</h3>\n<ul>\n<li>\n<p>direct method O(n)</p>\n<ul>\n<li>iterate the input array</li>\n<li>get the max one, record the index of that number</li>\n<li>calc the twice of each item and store it in another array</li>\n<li>iterate the other array, check the item is larger than ...</li>\n</ul>\n</li>\n</ul>\n<h3>Answer:</h3>\n<h3>Others Answer:</h3>","frontmatter":{"title":"Largest Number At Least Twice of Others","timeSpent":null,"qId":null,"date":"2020-04-26","conquered":null,"wrongTime":null,"withHelp":null}}},{"node":{"fields":{"slug":"/learn/array-and-string/introduction-to-array/plus-one/"},"html":"<h2>Plus One (20 mins)</h2>\n<h3>Question：</h3>\n<h5>Description:</h5>\n<ul>\n<li>Given a non-empty array of digits representing a non-negative integer, plus one to the integer.</li>\n<li>The digits are stored such that the most significant digit is at the head of the list, and each element in the array contain a single digit.</li>\n<li>You may assume the integer does not contain any leading zero, except the number 0 itself.</li>\n</ul>\n<h5>Note:</h5>\n<ul>\n<li>placeholder</li>\n</ul>\n<h5>Examples:</h5>\n<pre><code>Input: [1,2,3]\nOutput: [1,2,4]\nExplanation: The array represents the integer 123.\n\nInput: [4,3,2,1]\nOutput: [4,3,2,2]\nExplanation: The array represents the integer 4321.\n</code></pre>\n<h3>Process:</h3>\n<ul>\n<li>Just like Big Int Plus one, we need carry bit in the array.</li>\n</ul>\n<h3>Answer:</h3>\n<h3>Others Answer:</h3>","frontmatter":{"title":"Plus One","timeSpent":null,"qId":null,"date":"2020-04-26","conquered":null,"wrongTime":null,"withHelp":null}}},{"node":{"fields":{"slug":"/30days-challenge/week2/perform-string-shifts/"},"html":"<h2>Perform String Shifts ( mins)</h2>\n<h3>Question：</h3>\n<h5>Description:</h5>\n<ul>\n<li>You are given a string s containing lowercase English letters, and a matrix shift, where shift[i] = [direction, amount]:</li>\n<li>direction can be 0 (for left shift) or 1 (for right shift).</li>\n<li>amount is the amount by which string s is to be shifted.</li>\n<li>A left shift by 1 means remove the first character of s and append it to the end.</li>\n<li>Similarly, a right shift by 1 means remove the last character of s and add it to the beginning.</li>\n<li>Return the final string after all operations.</li>\n</ul>\n<h5>Constraints:</h5>\n<ul>\n<li>1 &#x3C;= s.length &#x3C;= 100</li>\n<li>s only contains lower case English letters.</li>\n<li>1 &#x3C;= shift.length &#x3C;= 100</li>\n<li>shift[i].length == 2</li>\n<li>0 &#x3C;= shift[i][0] &#x3C;= 1</li>\n<li>0 &#x3C;= shift[i][1] &#x3C;= 100</li>\n</ul>\n<h5>Examples:</h5>\n<pre><code>Input: s = \"abc\", shift = [[0,1],[1,2]]\nOutput: \"cab\"\nExplanation:\n[0,1] means shift to left by 1. \"abc\" -> \"bca\"\n[1,2] means shift to right by 2. \"bca\" -> \"cab\"\n\nInput: s = \"abcdefg\", shift = [[1,1],[1,1],[0,2],[1,3]]\nOutput: \"efgabcd\"\nExplanation:\n[1,1] means shift to right by 1. \"abcdefg\" -> \"gabcdef\"\n[1,1] means shift to right by 1. \"gabcdef\" -> \"fgabcde\"\n[0,2] means shift to left by 2. \"fgabcde\" -> \"abcdefg\"\n[1,3] means shift to right by 3. \"abcdefg\" -> \"efgabcd\"\n</code></pre>\n<h3>Process:</h3>\n<ul>\n<li>一不小心看到了 hints</li>\n<li>左右可以抵消。。。😂</li>\n</ul>\n<h3>Answer:</h3>\n<h3>Others Answer:</h3>","frontmatter":{"title":"Perform String Shifts","timeSpent":null,"qId":null,"date":"2020-04-20","conquered":null,"wrongTime":null,"withHelp":null}}},{"node":{"fields":{"slug":"/contest/0418/get-coin/"},"html":"<h2>minCount ( mins)</h2>\n<h3>Question：</h3>\n<h5>Description:</h5>\n<ul>\n<li>桌上有 n 堆力扣币，每堆的数量保存在数组 coins 中。我们每次可以选择任意一堆，拿走其中的一枚或者两枚，求拿完所有力扣币的最少次数。</li>\n</ul>\n<h5>LIMIT:</h5>\n<ul>\n<li>1 &#x3C;= n &#x3C;= 4</li>\n<li>1 &#x3C;= coins[i] &#x3C;= 10</li>\n</ul>\n<h5>Examples:</h5>\n<pre><code>输入：[4,2,1]\n\n输出：4\n\n解释：第一堆力扣币最少需要拿 2 次，第二堆最少需要拿 1 次，第三堆最少需要拿 1 次，总共 4 次即可拿完。\n</code></pre>\n<h3>Process:</h3>\n<ul>\n<li>placeholder</li>\n</ul>\n<h3>Answer:</h3>\n<h3>Others Answer:</h3>","frontmatter":{"title":"minCount","timeSpent":null,"qId":null,"date":"2020-04-18","conquered":null,"wrongTime":null,"withHelp":null}}},{"node":{"fields":{"slug":"/contest/0418/opera-time/"},"html":"<h2>getTriggerTime ( mins)</h2>\n<h3>Question：</h3>\n<h5>Description:</h5>\n<ul>\n<li>placeholder</li>\n</ul>\n<h5>Note:</h5>\n<ul>\n<li>placeholder</li>\n</ul>\n<h5>Examples:</h5>\n<pre><code>placeholder\n</code></pre>\n<h3>Process:</h3>\n<ul>\n<li>placeholder</li>\n</ul>\n<h3>Answer:</h3>\n<h3>Others Answer:</h3>","frontmatter":{"title":"getTriggerTime","timeSpent":null,"qId":null,"date":"2020-04-18","conquered":null,"wrongTime":null,"withHelp":null}}},{"node":{"fields":{"slug":"/contest/0418/pass-info/"},"html":"<h2>numWays ( mins)</h2>\n<h3>Question：</h3>\n<h5>Description:</h5>\n<ul>\n<li>小朋友 A 在和 ta 的小伙伴们玩传信息游戏，游戏规则如下：</li>\n<li>有 n 名玩家，所有玩家编号分别为 0 ～ n-1，其中小朋友 A 的编号为 0</li>\n<li>每个玩家都有固定的若干个可传信息的其他玩家（也可能没有）。传信息的关系是单向的（比如 A 可以向 B 传信息，但 B 不能向 A 传信息）。</li>\n<li>每轮信息必须需要传递给另一个人，且信息可重复经过同一个人</li>\n<li>给定总玩家数 n，以及按 [玩家编号,对应可传递玩家编号] 关系组成的二维数组 relation。返回信息从小 A (编号 0 ) 经过 k 轮传递到编号为 n-1 的小伙伴处的方案数；若不能到达，返回 0。</li>\n</ul>\n<h5>Note:</h5>\n<ul>\n<li>2 &#x3C;= n &#x3C;= 10</li>\n<li>1 &#x3C;= k &#x3C;= 5</li>\n<li>1 &#x3C;= relation.length &#x3C;= 90, 且 relation[i].length == 2</li>\n<li>0 &#x3C;= relation[i][0],relation[i][1] &#x3C; n 且 relation[i][0] != relation[i][1]</li>\n</ul>\n<h5>Examples:</h5>\n<pre><code>输入：n = 5, relation = [[0,2],[2,1],[3,4],[2,3],[1,4],[2,0],[0,4]], k = 3\n\n输出：3\n\n解释：信息从小 A 编号 0 处开始，经 3 轮传递，到达编号 4。共有 3 种方案，分别是 0->2->0->4， 0->2->1->4， 0->2->3->4。\n\n输入：n = 3, relation = [[0,2],[2,1]], k = 2\n\n输出：0\n\n解释：信息不能从小 A 处经过 2 轮传递到编号 2\n</code></pre>\n<h3>Process:</h3>\n<ul>\n<li>这是 一个图，或者说 是一个状态机，怎么处理</li>\n<li>这又是一个 可以拆分的子问题</li>\n</ul>\n<h3>Answer:</h3>\n<h3>Others Answer:</h3>","frontmatter":{"title":"numWays","timeSpent":null,"qId":null,"date":"2020-04-18","conquered":null,"wrongTime":null,"withHelp":null}}},{"node":{"fields":{"slug":"/30days-challenge/week2/product-except-self/"},"html":"<h2>productExceptSelf (20 mins)</h2>\n<h3>Question：</h3>\n<h5>Description:</h5>\n<ul>\n<li>Given an array nums of n integers where n > 1,  return an array output such that output[i] is equal to the product of all the elements of nums except nums[i].</li>\n</ul>\n<h5>Constraint:</h5>\n<ul>\n<li>It's guaranteed that the product of the elements of any prefix or suffix of the array (including the whole array) fits in a 32 bit integer.</li>\n</ul>\n<h5>Note:</h5>\n<ul>\n<li>Please solve it without division and in O(n).</li>\n</ul>\n<h5>Follow up:</h5>\n<ul>\n<li>Could you solve it with constant space complexity? (The output array does not count as extra space for the purpose of space complexity analysis.)</li>\n</ul>\n<h5>Examples:</h5>\n<pre><code>Input:  [1,2,3,4]\nOutput: [24,12,8,6]\n</code></pre>\n<h3>Process:</h3>\n<ul>\n<li>[1] => [1]</li>\n<li>[1,2] => [2,1]</li>\n<li>[1,2,3] => [2<em>3,1</em>3,1*2]</li>\n<li>[1,2,3,4] => [2<em>3</em>4,1<em>3</em>4,1<em>2</em>4,1<em>2</em>3]</li>\n<li>写着写着 发现不是O(n)...</li>\n<li>虽然通过了，有必要在研究下 的</li>\n</ul>\n<h3>Answer:</h3>\n<h3>Others Answer:</h3>","frontmatter":{"title":"productExceptSelf","timeSpent":null,"qId":null,"date":"2020-04-16","conquered":null,"wrongTime":null,"withHelp":null}}},{"node":{"fields":{"slug":"/30days-challenge/week2/contiguous-array/"},"html":"<h2>Contiguous Array (50 mins)</h2>\n<h3>Question：</h3>\n<h5>Description:</h5>\n<ul>\n<li>Given a binary array, find the maximum length of a contiguous subarray with equal number of 0 and 1.</li>\n</ul>\n<h5>Note:</h5>\n<ul>\n<li>The length of the given binary array will not exceed 50,000.</li>\n</ul>\n<h5>Examples:</h5>\n<pre><code>Input: [0,1]\nOutput: 2\nExplanation: [0, 1] is the longest contiguous subarray with equal number of 0 and 1.\n\nInput: [0,1,0]\nOutput: 2\nExplanation: [0, 1] (or [1, 0]) is a longest contiguous subarray with equal number of 0 and 1.\n</code></pre>\n<h3>Process:</h3>\n<ul>\n<li>首先 第一次题目理解错了，以为 连续的01/10的数量</li>\n<li>其实 应该是 00001111，也算</li>\n<li>\n<p>能不能遍历数组，记录一遍每个节点的信息</p>\n<ul>\n<li>[0, 1, 0, 0, 0, 1, 1]</li>\n<li>=></li>\n<li>0: {0: 1, 1: 0}</li>\n<li>1: {0: 1, 1: 1}</li>\n<li>0: {0: 2, 1: 1}</li>\n<li>0: {0: 3, 1: 1}</li>\n<li>0: {0: 4, 1: 1}</li>\n<li>1: {0: 4, 1: 2}</li>\n<li>1: {0: 4, 1: 3}</li>\n</ul>\n</li>\n<li>感觉上面的解法挺有意思，但是怎么证明他是对的呢？怎么证明连续的一组数据就是正确的呢</li>\n<li>[0,1,1,0,1,1,1,0] 这个数组 证明，我的方法是错的， 没有连续。</li>\n<li>确实哦，我这个没有判断连续，那么如何包含这种情况呢</li>\n<li>我的结论是这样基本是错的，又不是让你找从数组的一开始，有多少个同样的0、1，没必要保留从0开始的有多少个0，1</li>\n<li><strong>动态规划，len每增加一，当前最优解，要么是不用新增的值，要么是使用新增的值</strong></li>\n<li>没用动态规划想出来，大佬也没有嘿嘿嘿</li>\n<li>我想到 每个节点 保存 已经有的0和1的值了，</li>\n<li>但是 最后判断结果的一步错了，应该是 0和1个数相等的点是平衡点，两个平衡点之间0，1的个数一定是相等的，所以返回的就是最大的两个平衡点的距离</li>\n<li>平衡点 不一定是 0、1个数相等的点，</li>\n<li>而是 每个节点累计 0，1计算下来，画出这样一条线，y值相等的点之间的最远距离就是结果</li>\n<li>开心，豁然开朗</li>\n</ul>\n<h3>Answer:</h3>\n<h3>Others Answer:</h3>","frontmatter":{"title":" Contiguous Array","timeSpent":null,"qId":null,"date":"2020-04-14","conquered":null,"wrongTime":null,"withHelp":null}}},{"node":{"fields":{"slug":"/30days-challenge/week2/diameter-of-binary-tree/"},"html":"<h2>diameterOfBinaryTree ( mins)</h2>\n<h3>Question：</h3>\n<h5>Description:</h5>\n<ul>\n<li>Given a binary tree, you need to compute the length of the diameter of the tree. The diameter of a binary tree is the length of the longest path between any two nodes in a tree. This path may or may not pass through the root.</li>\n</ul>\n<h5>Note:</h5>\n<ul>\n<li>The length of path between two nodes is represented by the number of edges between them.</li>\n</ul>\n<h5>Examples:</h5>\n<pre><code>          1\n         / \\\n        2   3\n       / \\\n      4   5\n\nReturn 3, which is the length of the path [4,2,1,3] or [5,2,1,3].\n</code></pre>\n<h3>Process:</h3>\n<ul>\n<li>placeholder</li>\n</ul>\n<h3>Answer:</h3>\n<h3>Others Answer:</h3>","frontmatter":{"title":"diameterOfBinaryTree","timeSpent":null,"qId":null,"date":"2020-04-14","conquered":null,"wrongTime":null,"withHelp":null}}},{"node":{"fields":{"slug":"/30days-challenge/week2/last-stone-weight/"},"html":"<h2>lastStoneWeight (30 mins)</h2>\n<h3>Question：</h3>\n<h5>Description:</h5>\n<ul>\n<li>We have a collection of stones, each stone has a positive integer weight.</li>\n<li>\n<p>Each turn, we choose the two heaviest stones and smash them together.  Suppose the stones have weights x and y with x &#x3C;= y.  The result of this smash is:</p>\n<ul>\n<li>If x == y, both stones are totally destroyed;</li>\n<li>If x != y, the stone of weight x is totally destroyed, and the stone of weight y has new weight y-x.</li>\n<li>At the end, there is at most 1 stone left.  Return the weight of this stone (or 0 if there are no stones left.)</li>\n</ul>\n</li>\n</ul>\n<h5>Note:</h5>\n<ul>\n<li>1 &#x3C;= stones.length &#x3C;= 30</li>\n<li>1 &#x3C;= stones[i] &#x3C;= 1000</li>\n</ul>\n<h5>Examples:</h5>\n<pre><code>Input: [2,7,4,1,8,1]\nOutput: 1\nExplanation:\nWe combine 7 and 8 to get 1 so the array converts to [2,4,1,1,1] then,\nwe combine 2 and 4 to get 2 so the array converts to [2,1,1,1] then,\nwe combine 2 and 1 to get 1 so the array converts to [1,1,1] then,\nwe combine 1 and 1 to get 0 so the array converts to [1] then that's the value of last stone.\n</code></pre>\n<h3>Process:</h3>\n<ul>\n<li>原以为大家都会自己写一个排序的，谁知道 都用了sort hhh</li>\n</ul>\n<h3>Answer:</h3>\n<h3>Others Answer:</h3>","frontmatter":{"title":"lastStoneWeight","timeSpent":null,"qId":null,"date":"2020-04-13","conquered":null,"wrongTime":null,"withHelp":null}}},{"node":{"fields":{"slug":"/30days-challenge/week2/min-stack/"},"html":"<h2>MinStack ( mins)</h2>\n<h3>Question：</h3>\n<h5>Description:</h5>\n<ul>\n<li>Design a stack that supports <code>push, pop, top, and retrieving the minimum element</code> in <strong>constant</strong> time.</li>\n<li>\n<p>functionality</p>\n<ul>\n<li>push(x) -- Push element x onto stack.</li>\n<li>pop() -- Removes the element on top of the stack.</li>\n<li>top() -- Get the top element.</li>\n<li>getMin() -- Retrieve the minimum element in the stack.</li>\n</ul>\n</li>\n</ul>\n<h5>Hite:</h5>\n<ul>\n<li>Consider each node in the stack having a minimum value. (Credits to @aakarshmadhavan)</li>\n</ul>\n<h5>Examples:</h5>\n<pre><code>MinStack minStack = new MinStack();\nminStack.push(-2);\nminStack.push(0);\nminStack.push(-3);\nminStack.getMin();   --> Returns -3.\nminStack.pop();\nminStack.top();      --> Returns 0.\nminStack.getMin();   --> Returns -2.\n</code></pre>\n<h3>Process:</h3>\n<ul>\n<li>有点意思，既然是要 O(1) 这样的方式操作，就必须多保存一些信息，并且在每步操作的时候就得记录和更新。</li>\n<li>一开始没想出来，看到提示恍然大悟。。。</li>\n</ul>\n<h3>Answer:</h3>\n<h3>Others Answer:</h3>","frontmatter":{"title":"MinStack","timeSpent":null,"qId":null,"date":"2020-04-10","conquered":null,"wrongTime":null,"withHelp":null}}},{"node":{"fields":{"slug":"/30days-challenge/week2/backspace-str-compare/"},"html":"<h2>backspaceCompare (16 mins)</h2>\n<h3>Question：</h3>\n<h5>Description:</h5>\n<ul>\n<li>Given two strings S and T, return if they are equal when both are typed into empty text editors. # means a backspace character.</li>\n</ul>\n<h5>Note:</h5>\n<ul>\n<li>1 &#x3C;= S.length &#x3C;= 200</li>\n<li>1 &#x3C;= T.length &#x3C;= 200</li>\n<li>S and T only contain lowercase letters and '#' characters.</li>\n<li>Can you solve it in O(N) time and O(1) space?</li>\n</ul>\n<h5>Examples:</h5>\n<pre><code>Input: S = \"ab#c\", T = \"ad#c\"\nOutput: true\nExplanation: Both S and T become \"ac\".\n\nInput: S = \"ab##\", T = \"c#d#\"\nOutput: true\nExplanation: Both S and T become \"\".\n\nInput: S = \"a##c\", T = \"#a#c\"\nOutput: true\nExplanation: Both S and T become \"c\".\n\nInput: S = \"a#c\", T = \"b\"\nOutput: false\nExplanation: S becomes \"c\" while T becomes \"b\".\n</code></pre>\n<h3>Process:</h3>\n<ul>\n<li>一种想法，应该很容易实现的是 分别算出两个的值，然后对比</li>\n<li>另一个想法，算一个值，然后直接验证另一个</li>\n<li>第三种想法，同时指针运算两个字符串？</li>\n</ul>\n<h3>Answer:</h3>\n<h3>Others Answer:</h3>","frontmatter":{"title":"backspaceCompare","timeSpent":null,"qId":null,"date":"2020-04-09","conquered":null,"wrongTime":null,"withHelp":null}}},{"node":{"fields":{"slug":"/30days-challenge/week2/middle-of-the-linked-list/"},"html":"<h2>Middle of the Linked List (10 mins)</h2>\n<h3>Question：</h3>\n<h5>Description:</h5>\n<ul>\n<li>Given a non-empty, singly linked list with head node head, return a middle node of linked list.</li>\n<li>If there are two middle nodes, return the second middle node.</li>\n</ul>\n<h5>Note:</h5>\n<ul>\n<li>The number of nodes in the given list will be between 1 and 100.</li>\n</ul>\n<h5>Examples:</h5>\n<pre><code>Input: [1,2,3,4,5]\nOutput: Node 3 from this list (Serialization: [3,4,5])\nThe returned node has value 3.  (The judge's serialization of this node is [3,4,5]).\nNote that we returned a ListNode object ans, such that:\nans.val = 3, ans.next.val = 4, ans.next.next.val = 5, and ans.next.next.next = NULL.\n\nInput: [1,2,3,4,5,6]\nOutput: Node 4 from this list (Serialization: [4,5,6])\nSince the list has two middle nodes with values 3 and 4, we return the second one.\n</code></pre>\n<h3>Process:</h3>\n<ul>\n<li>mark 感觉mark一下，遍历的时候把每个序号存一下，然后到时候直接return 这个obj 就可以了 o1 的算法</li>\n</ul>\n<h3>Answer:</h3>\n<h3>Others Answer:</h3>","frontmatter":{"title":"Middle of the Linked List","timeSpent":null,"qId":null,"date":"2020-04-09","conquered":null,"wrongTime":null,"withHelp":null}}},{"node":{"fields":{"slug":"/30days-challenge/week1/counting-elements/"},"html":"<h2>countElements (8 mins)</h2>\n<h3>Question：</h3>\n<h5>Description:</h5>\n<ul>\n<li>Given an integer array arr, count element x such that x + 1 is also in arr.</li>\n<li>If there're duplicates in arr, count them seperately.</li>\n</ul>\n<h5>Note:</h5>\n<ul>\n<li>placeholder</li>\n</ul>\n<h5>Examples:</h5>\n<pre><code>Input: arr = [1,2,3]\nOutput: 2\nExplanation: 1 and 2 are counted cause 2 and 3 are in arr.\n\nInput: arr = [1,1,3,3,5,5,7,7]\nOutput: 0\nExplanation: No numbers are counted, cause there's no 2, 4, 6, or 8 in arr.\n\nInput: arr = [1,3,2,3,5,0]\nOutput: 3\nExplanation: 0, 1 and 2 are counted cause 1, 2 and 3 are in arr.\n\nInput: arr = [1,1,2,2]\nOutput: 2\nExplanation: Two 1s are counted cause 2 is in arr.\n</code></pre>\n<h3>Process:</h3>\n<ul>\n<li>有一点感觉了，看到这个题目就想到 用object 累加下，扫一遍得到所有的数据的count</li>\n<li>在扫一遍，就知道所有结果了</li>\n</ul>\n<h3>Answer:</h3>\n<h3>Others Answer:</h3>","frontmatter":{"title":"countElements","timeSpent":null,"qId":null,"date":"2020-04-08","conquered":null,"wrongTime":null,"withHelp":null}}},{"node":{"fields":{"slug":"/30days-challenge/week1/group-anagrams/"},"html":"<h2>groupAnagrams ( mins)</h2>\n<h3>Question：</h3>\n<h5>Description:</h5>\n<ul>\n<li>Given an array of strings, group anagrams together.</li>\n</ul>\n<h5>Note:</h5>\n<ul>\n<li>All inputs will be in lowercase.</li>\n<li>The order of your output does not matter.</li>\n</ul>\n<h5>Examples:</h5>\n<pre><code>Input: [\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"],\nOutput:\n[\n  [\"ate\",\"eat\",\"tea\"],\n  [\"nat\",\"tan\"],\n  [\"bat\"]\n]\n</code></pre>\n<h3>Process:</h3>\n<ul>\n<li>placeholder</li>\n</ul>\n<h3>Answer:</h3>\n<h3>Others Answer:</h3>","frontmatter":{"title":"groupAnagrams","timeSpent":null,"qId":null,"date":"2020-04-08","conquered":null,"wrongTime":null,"withHelp":null}}},{"node":{"fields":{"slug":"/30days-challenge/week1/best-time-to-buy-and-sell-stock-2/"},"html":"<h2>sellStock2 (47 mins)</h2>\n<h3>Question：</h3>\n<h5>Description:</h5>\n<ul>\n<li>Say you have an array for which the ith element is the price of a given stock on day i.</li>\n<li>Design an algorithm to find the maximum profit. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times).</li>\n</ul>\n<h5>Note:</h5>\n<ul>\n<li>You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again).</li>\n</ul>\n<h5>Examples:</h5>\n<pre><code>Input: [7,1,5,3,6,4]\nOutput: 7\nExplanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.\n             Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.\n\nInput: [1,2,3,4,5]\nOutput: 4\nExplanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.\n             Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are\n             engaging multiple transactions at the same time. You must sell before buying again.\n\nInput: [7,6,4,3,1]\nOutput: 0\nExplanation: In this case, no transaction is done, i.e. max profit = 0.\n</code></pre>\n<h3>Process:</h3>\n<ul>\n<li>一天只支持一个操作，要么买，要么买了</li>\n<li>这个题目 看下来 有点像 找最大连续的上升子区间 收尾做差，不同区间累加</li>\n</ul>\n<p>是这样的，提交的时候失败了两次，都是 判断 leftBoundary 存在的时候简单的使用了 (!xxx), (xxx) 而不是 === undefined 来判断</p>\n<h3>Answer:</h3>\n<h3>Others Answer:</h3>","frontmatter":{"title":"sellStock2","timeSpent":null,"qId":null,"date":"2020-04-07","conquered":null,"wrongTime":null,"withHelp":null}}},{"node":{"fields":{"slug":"/30days-challenge/week1/move-zeros/"},"html":"<h2>moveZeroes ( mins)</h2>\n<h3>Question：</h3>\n<h5>Description:</h5>\n<ul>\n<li>Given an array nums, write a function to move all 0's to the end of it while maintaining the relative order of the non-zero elements.</li>\n</ul>\n<h5>Note:</h5>\n<ul>\n<li>You must do this in-place without making a copy of the array.</li>\n<li>Minimize the total number of operations.</li>\n</ul>\n<h5>Examples:</h5>\n<pre><code>Input: [0,1,0,3,12]\nOutput: [1,3,12,0,0]\n</code></pre>\n<h3>Process:</h3>\n<ul>\n<li>placeholder</li>\n</ul>\n<h3>Answer:</h3>\n<h3>Others Answer:</h3>","frontmatter":{"title":"moveZeroes","timeSpent":null,"qId":null,"date":"2020-04-07","conquered":null,"wrongTime":null,"withHelp":null}}},{"node":{"fields":{"slug":"/30days-challenge/week1/maximum-subarray/"},"html":"<h2>maxSubArray ( mins)</h2>\n<h3>Question：</h3>\n<h5>Description:</h5>\n<ul>\n<li>Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.</li>\n</ul>\n<h5>Note:</h5>\n<ul>\n<li>If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle.</li>\n</ul>\n<h5>Examples:</h5>\n<pre><code>Input: [-2,1,-3,4,-1,2,1,-5,4],\nOutput: 6\nExplanation: [4,-1,2,1] has the largest sum = 6.\n</code></pre>\n<h3>Process:</h3>\n<ul>\n<li>一开始完全无从下手，暴力求解 bruta force也没有去想。。O(n ^ 3)</li>\n<li>后来做到后面有意识这道题是动态规划，还是没有去做出来</li>\n<li>后来听了个youtube老哥的视频<a href=\"https://www.youtube.com/watch?v=jcjXgmHHpds\">https://www.youtube.com/watch?v=jcjXgmHHpds</a></li>\n<li>后来恍然大悟</li>\n<li>主要还是证明自己的理解是对的，或者说 理解 为什么前后会有关联的过程</li>\n<li>可以看到解法中sum 对应的项代表，遍历到这里的时候的最大值，</li>\n<li>两种情况，一种是 前面最大值加上自己（连续下去）</li>\n<li>另一种是 就是当前的值，（重新计数）</li>\n<li>第一种情况，前面的最大值加上自己，这个也没有限制 是哪个区间段，不过总体两个走向，加上自己，或者从头再来，还是很有道理的。</li>\n<li>主要是 没有想通，为什么 一定只有两种方式</li>\n<li>\n<p>为什么  不可以什么都不做。取之前的。</p>\n<ul>\n<li>这个我理解是 为了连续 所以要这么算，具体取不取之前的，这个最后会有定论/</li>\n</ul>\n</li>\n<li>所以 针对新值，实际有三种情况，连续下去，，重投再来，索性不管，索性不管我们不考虑，在另一个唯独考虑，处于连续性只考虑两种</li>\n</ul>\n<h3>Answer:</h3>\n<h3>Others Answer:</h3>","frontmatter":{"title":"maxSubArray","timeSpent":null,"qId":null,"date":"2020-04-06","conquered":null,"wrongTime":null,"withHelp":null}}},{"node":{"fields":{"slug":"/30days-challenge/week1/happy-number/"},"html":"<h2>Happy Number (48mins)</h2>\n<h3>Question：</h3>\n<h5>Description:</h5>\n<ul>\n<li>Write an algorithm to determine if a number is \"happy\".</li>\n<li>A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy numbers.</li>\n</ul>\n<!-- ##### Note:\n* Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory? -->\n<h5>Examples:</h5>\n<pre><code>Input: 19\nOutput: true\nExplanation:\n1^2 + 9^2 = 82\n8^2 + 2^2 = 68\n6^2 + 8^2 = 100\n1^2 + 0^2 + 0^2 = 1\n</code></pre>\n<h3>Process:</h3>\n<ol>\n<li>保存计算过的部分，这个有助于减少循环的次数</li>\n<li>如何judge死循环呢？</li>\n<li><strong>这两个可能得放在一起考虑，保存的是一个数组，\n递归函数把计算过程也带上去了，如果数组中出现已经算过了，那么就证明有循环了，判定false</strong></li>\n</ol>\n<h3>Answer:</h3>\n<h3>Others Answer:</h3>","frontmatter":{"title":"Happy Number","timeSpent":null,"qId":null,"date":"2020-04-05","conquered":null,"wrongTime":null,"withHelp":null}}},{"node":{"fields":{"slug":"/30days-challenge/week1/single-number/"},"html":"<h2>Single Number</h2>\n<h3>Question：</h3>\n<h5>Description:</h5>\n<ul>\n<li>Given a non-empty array of integers, every element appears twice except for one. Find that single one.</li>\n</ul>\n<h5>Note:</h5>\n<ul>\n<li>Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?</li>\n</ul>\n<h5>Examples:</h5>\n<pre><code>Input: [2,2,1]\nOutput: 1\n\nInput: [4,1,2,1,2]\nOutput: 4\n</code></pre>\n<h3>Answer:</h3>\n<h3>Others Answer:</h3>","frontmatter":{"title":"Single Number","timeSpent":null,"qId":null,"date":"2020-04-04","conquered":null,"wrongTime":null,"withHelp":null}}}]}},"pageContext":{}}}