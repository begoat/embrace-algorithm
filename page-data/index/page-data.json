{"componentChunkName":"component---src-templates-blog-index-tsx","path":"/","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"fields":{"slug":"/learn/array-101/in-place-operations/README/"},"html":"","frontmatter":{"title":"","timeSpent":null,"qId":null,"date":null,"conquered":null,"wrongTime":null,"withHelp":null}}},{"node":{"fields":{"slug":"/30days-challenge/week1/"},"html":"<h4><a href=\"https://leetcode.com/explore/challenge/card/30-day-leetcoding-challenge/528/week-1\">https://leetcode.com/explore/challenge/card/30-day-leetcoding-challenge/528/week-1</a></h4>","frontmatter":{"title":"","timeSpent":null,"qId":null,"date":null,"conquered":null,"wrongTime":null,"withHelp":null}}},{"node":{"fields":{"slug":"/30days-challenge/week2/"},"html":"<h4><a href=\"https://leetcode.com/explore/challenge/card/30-day-leetcoding-challenge/529/week-2/\">https://leetcode.com/explore/challenge/card/30-day-leetcoding-challenge/529/week-2/</a></h4>","frontmatter":{"title":"","timeSpent":null,"qId":null,"date":null,"conquered":null,"wrongTime":null,"withHelp":null}}},{"node":{"fields":{"slug":"/learn/array-101/conclusion/README/"},"html":"<h3>What's Next?</h3>\n<p>Let's recap what we looked at in this explore card:</p>\n<ul>\n<li>We explored what the Array data structure is all about.</li>\n<li>We looked at the Java syntax for creating Arrays.</li>\n<li>We looked at the Java syntax for reading and writing from Arrays.</li>\n<li>We designed basic insertion, deletion, and search algorithms for Arrays.</li>\n<li>We played around with in-place Array algorithms.</li>\n<li>We solved heaps of fun and exciting problems!</li>\n</ul>\n<p>Here at LeetCode, we've already started developing a follow-up Arrays Explore Card! In that card, we'll be going over some more advanced techniques for working with Arrays.</p>\n<p>What other techniques could there be with Arrays, you might be wondering? Well, wonder no more. Here is a quick taster!</p>\n<p><img src=\"https://leetcode.com/explore/learn/card/fun-with-arrays/523/conclusion/Figures/Array_Explore/Array_Basics_Conclusion_1.png\" alt=\"techs\"></p>\n<p>For now though, here's a few last questions for you to really practice what you've learned, and to get prepared for the next Arrays Explore Card!</p>","frontmatter":{"title":"","timeSpent":null,"qId":null,"date":null,"conquered":null,"wrongTime":null,"withHelp":null}}},{"node":{"fields":{"slug":"/learn/array-101/searching-for-items-in-an-array/README/"},"html":"<h3>Search in an Array</h3>\n<ol>\n<li>Linear Search</li>\n<li>If the index is not known, which is the case most of the time, then we can check every element in the Array. We continue checking elements until we find the element we're looking for, or we reach the end of the Array. This technique for finding an element by checking through all elements one by one is known as the linear search algorithm. In the worst case, a linear search ends up checking the entire Array. Therefore, the time complexity for a linear search is O(N)O(N).</li>\n<li>Binary Search</li>\n<li>There is another way of searching an Array. If the elements in the Array are in sorted order, then we can use binary search.</li>\n<li>Binary search is where we repeatedly look at the middle element in the Array, and determine whether the element we're looking for must be to the left, or to the right. Each time we do this, we're able to halve the number of elements we still need to search, making binary search a lot faster than linear search!</li>\n</ol>","frontmatter":{"title":"","timeSpent":null,"qId":null,"date":null,"conquered":null,"wrongTime":null,"withHelp":null}}},{"node":{"fields":{"slug":"/learn/array-and-string/array-two-pointer-technique/README/"},"html":"<h3>Two-pointer Technique</h3>\n<p>In the previous chapter, we solve some problems by iterating the array. Typically, we only use one pointer starting from the first element and ending at the last one to do iteration. However, sometimes, we might need to use two pointers at the same time to do the iteration.</p>\n<h4>Summary</h4>\n<ul>\n<li>\n<p>To summarize, one of the typical scenarios to use two-pointer technique is that you want to</p>\n<blockquote>\n<p>Iterate the array from two ends to the middle.</p>\n</blockquote>\n<blockquote>\n<p>And it is worth noting that this technique is often used in a sorted array.</p>\n</blockquote>\n</li>\n<li>\n<p>This is a very common scenario of using the two-pointer technique when you need:</p>\n<blockquote>\n<p>One slow-runner and one fast-runner at the same time.</p>\n</blockquote>\n<blockquote>\n<p>The key to solving this kind of problems is to <strong>Determine the movement strategy for both pointers.</strong></p>\n</blockquote>\n<blockquote>\n<p>Similar to the previous scenario, you might sometimes need to sort the array before using the two-pointer technique. And you might need a greedy thought to determine your movement strategy.</p>\n</blockquote>\n</li>\n</ul>","frontmatter":{"title":"","timeSpent":null,"qId":null,"date":null,"conquered":null,"wrongTime":null,"withHelp":null}}},{"node":{"fields":{"slug":"/learn/array-and-string/conclusion/README/"},"html":"<h3>Array-related Techniques</h3>\n<ul>\n<li>String (has been introduced in this card)</li>\n<li>Hash Table</li>\n<li>Linked List</li>\n<li>Queue</li>\n<li>Stack</li>\n</ul>","frontmatter":{"title":"","timeSpent":null,"qId":null,"date":null,"conquered":null,"wrongTime":null,"withHelp":null}}},{"node":{"fields":{"slug":"/learn/array-and-string/introduction-to-2d-array/README/"},"html":"<h3>Introduction to 2D Array</h3>\n<p>In the previous chapter, we have learned about the <code>one-dimensional array</code>. However, sometimes, we might need a <code>multidimensional array</code> which is more suitable for more complex structures like table or matrix.</p>\n<p>In this chapter, we are going to focus on the <code>two-dimensional array</code> to explain:</p>\n<p>How does a multidimensional array work?\nHow to use a two-dimensional array to solve problems?</p>","frontmatter":{"title":"","timeSpent":null,"qId":null,"date":null,"conquered":null,"wrongTime":null,"withHelp":null}}},{"node":{"fields":{"slug":"/learn/array-and-string/introduction-to-string/README/"},"html":"<h3>Immutable String - Problems &#x26; Solutions</h3>\n<h4>Tips:</h4>\n<ul>\n<li>You should be aware of the time complexity of these built-in operations.</li>\n<li>For instance, if the length of the string is N, the time complexity of both finding operation and substring operation is O(N).</li>\n<li>Also, in languages which the string is immutable, you should be careful with the concatenation operation (we will explain this in next article as well).</li>\n<li>Never forget to take the time complexity of built-in operations into consideration when you compute the time complexity for your solution.</li>\n</ul>\n<h4>Immutable String</h4>\n<pre><code class=\"language-java\">public class Main {\n    public static void main(String[] args) {\n        String s = \"\";\n        int n = 10000;\n        for (int i = 0; i &#x3C; n; i++) {\n            s += \"hello\";\n        }\n    }\n}\n</code></pre>\n<p>In Java, since the string is immutable, concatenation works by first allocating enough space for the new string, copy the contents from the old string and append to the new string.</p>\n<p>Therefore, the time complexity in total will be:</p>\n<p>   5 + 5 × 2 + 5 × 3 + … + 5 × n\n= 5 × (1 + 2 + 3 + … + n)\n= 5 × n × (n + 1) / 2,</p>\n<p>which is O(n2).</p>\n<h4>Solution</h4>\n<ol>\n<li><strong>If you did want your string to be mutable, you can convert it to a char array.</strong></li>\n<li>If you have to concatenate strings often, it will be better to use some other data structures like StringBuilder. The below code runs in O(n) complexity.</li>\n</ol>\n<h4>reference:</h4>\n<ul>\n<li><a href=\"https://leetcode.com/explore/learn/card/array-and-string/203/introduction-to-string/1184/\">https://leetcode.com/explore/learn/card/array-and-string/203/introduction-to-string/1184/</a></li>\n</ul>","frontmatter":{"title":"","timeSpent":null,"qId":null,"date":null,"conquered":null,"wrongTime":null,"withHelp":null}}},{"node":{"fields":{"slug":"/learn/array-101/conclusion/find-all-numbers-disappeared-in-an-array/"},"html":"<h2>findDisappearedNumbers (50 mins)</h2>\n<h3>Question：</h3>\n<h5>Description:</h5>\n<ul>\n<li>Given an array of integers where 1 ≤ a[i] ≤ n (n = size of array), some elements appear twice and others appear once.</li>\n<li>Find all the elements of [1, n] inclusive that do not appear in this array.</li>\n<li>Could you do it without extra space and in O(n) runtime? You may assume the returned list does not count as extra space.</li>\n</ul>\n<h5>Note:</h5>\n<ul>\n<li>placeholder</li>\n</ul>\n<h5>Examples:</h5>\n<pre><code>Input:\n[4,3,2,7,8,2,3,1]\n\nOutput:\n[5,6]\n</code></pre>\n<h3>Process:</h3>\n<ul>\n<li><a href=\"https://www.youtube.com/watch?v=efU_3Da3DV0\">https://www.youtube.com/watch?v=efU_3Da3DV0</a> 看了这个老哥的，把我惊呆了，直接用了一个dict。。。</li>\n<li>当然我一开始题目意思理解错了，without extra space, returned list 也是可以直接用的。</li>\n</ul>\n<h3>Answer:</h3>\n<h3>Others Answer:</h3>","frontmatter":{"title":"findDisappearedNumbers","timeSpent":50,"qId":null,"date":"2020-05-10","conquered":null,"wrongTime":null,"withHelp":null}}},{"node":{"fields":{"slug":"/learn/array-101/conclusion/third-maximum-number/"},"html":"<h2>Third Maximum Number (10 mins)</h2>\n<h3>Question：</h3>\n<h5>Description:</h5>\n<ul>\n<li>Given a non-empty array of integers, return the third maximum number in this array. If it does not exist, return the maximum number. The time complexity must be in O(n).</li>\n</ul>\n<h5>Note:</h5>\n<ul>\n<li>placeholder</li>\n</ul>\n<h5>Examples:</h5>\n<pre><code>Input: [3, 2, 1]\n\nOutput: 1\n\nExplanation: The third maximum is 1.\n\nInput: [1, 2]\n\nOutput: 2\n\nExplanation: The third maximum does not exist, so the maximum (2) is returned instead.\n\nInput: [2, 2, 3, 1]\n\nOutput: 1\n\nExplanation: Note that the third maximum here means the third maximum distinct number.\nBoth numbers with value 2 are both considered as second maximum.\n</code></pre>\n<h3>Process:</h3>\n<ul>\n<li>placeholder</li>\n</ul>\n<h3>Answer:</h3>\n<h3>Others Answer:</h3>","frontmatter":{"title":"Third Maximum Number","timeSpent":10,"qId":null,"date":"2020-05-10","conquered":null,"wrongTime":null,"withHelp":null}}},{"node":{"fields":{"slug":"/learn/array-101/conclusion/height-checker/"},"html":"<h2>Height Checker (10 mins)</h2>\n<h3>Question：</h3>\n<h5>Description:</h5>\n<ul>\n<li>Students are asked to stand in non-decreasing order of heights for an annual photo.</li>\n<li>Return the minimum number of students that must move in order for all students to be standing in non-decreasing order of height.</li>\n<li>Notice that when a group of students is selected they can reorder in any possible way between themselves and the non selected students remain on their seats.</li>\n</ul>\n<h5>Constraints:</h5>\n<ul>\n<li>1 &#x3C;= heights.length &#x3C;= 100</li>\n<li>1 &#x3C;= heights[i] &#x3C;= 100</li>\n</ul>\n<h5>Examples:</h5>\n<pre><code>Input: heights = [1,1,4,2,1,3]\nOutput: 3\nExplanation:\nCurrent array : [1,1,4,2,1,3]\nTarget array  : [1,1,1,2,3,4]\nOn index 2 (0-based) we have 4 vs 1 so we have to move this student.\nOn index 4 (0-based) we have 1 vs 3 so we have to move this student.\nOn index 5 (0-based) we have 3 vs 4 so we have to move this student.\n\nInput: heights = [5,1,2,3,4]\nOutput: 5\n\nInput: heights = [1,2,3,4,5]\nOutput: 0\n</code></pre>\n<h3>Process:</h3>\n<ul>\n<li>\n<p>这道题主要是理解题意</p>\n<ul>\n<li>哪些学生是不要懂的</li>\n</ul>\n</li>\n<li>一个排序一个对比</li>\n<li>一个insertion sort 就可以走天下了</li>\n</ul>\n<h3>Answer:</h3>\n<h3>Others Answer:</h3>","frontmatter":{"title":"Height Checker","timeSpent":10,"qId":null,"date":"2020-05-09","conquered":null,"wrongTime":null,"withHelp":null}}},{"node":{"fields":{"slug":"/learn/array-101/in-place-operations/replace-elements-with-greatest-element-on-right-side/"},"html":"<h2>Replace Elements with Greatest Element on Right Side ( mins)</h2>\n<h3>Question：</h3>\n<h5>Description:</h5>\n<ul>\n<li>Given an array arr, replace every element in that array with the greatest element among the elements to its right, and replace the last element with -1.</li>\n<li>After doing so, return the array.</li>\n</ul>\n<h5>Note:</h5>\n<ul>\n<li>1 &#x3C;= arr.length &#x3C;= 10^4</li>\n<li>1 &#x3C;= arr[i] &#x3C;= 10^5</li>\n</ul>\n<h5>Examples:</h5>\n<pre><code>Input: arr = [17,18,5,4,6,1]\nOutput: [18,6,6,6,1,-1]\n</code></pre>\n<h3>Process:</h3>\n<ul>\n<li>\n<p>看了几遍才看懂， 是真的好几遍。。。</p>\n<ul>\n<li>对每一个元素 都用它右边的最大的元素替代</li>\n</ul>\n</li>\n<li>典型的O(n^2)</li>\n</ul>\n<h3>Answer:</h3>\n<h3>Others Answer:</h3>","frontmatter":{"title":"Replace Elements with Greatest Element on Right Side","timeSpent":0,"qId":null,"date":"2020-05-09","conquered":null,"wrongTime":null,"withHelp":null}}},{"node":{"fields":{"slug":"/learn/array-101/in-place-operations/sort-array-by-parity/"},"html":"<h2>Sort Array By Parity (20 mins)</h2>\n<h3>Question：</h3>\n<h5>Description:</h5>\n<ul>\n<li>Given an array A of non-negative integers, return an array consisting of all the even elements of A, followed by all the odd elements of A.</li>\n<li>You may return any answer array that satisfies this condition.</li>\n</ul>\n<h5>Note:</h5>\n<ul>\n<li>1 &#x3C;= A.length &#x3C;= 5000</li>\n<li>0 &#x3C;= A[i] &#x3C;= 5000</li>\n</ul>\n<h5>Examples:</h5>\n<pre><code>Input: [3,1,2,4]\nOutput: [2,4,3,1]\nThe outputs [4,2,3,1], [2,4,1,3], and [4,2,1,3] would also be accepted.\n</code></pre>\n<h3>Process:</h3>\n<ul>\n<li>\n<p>we need two pointer</p>\n<ul>\n<li>one to do the main loop</li>\n<li>the other is to records the position of the end of the element in origin array</li>\n</ul>\n</li>\n</ul>\n<h3>Answer:</h3>\n<h3>Others Answer:</h3>","frontmatter":{"title":"Sort Array By Parity","timeSpent":20,"qId":null,"date":"2020-05-09","conquered":null,"wrongTime":null,"withHelp":null}}},{"node":{"fields":{"slug":"/learn/array-101/in-place-operations/squares-of-a-sorted-array/"},"html":"<h2>Squares of a Sorted Array (40 mins)</h2>\n<h3>Question：</h3>\n<h5>Description:</h5>\n<ul>\n<li>Given an array of integers A sorted in non-decreasing order, return an array of the squares of each number, also in sorted non-decreasing order.</li>\n</ul>\n<h5>Note:</h5>\n<ul>\n<li>1 &#x3C;= A.length &#x3C;= 10000</li>\n<li>-10000 &#x3C;= A[i] &#x3C;= 10000</li>\n<li>A is sorted in non-decreasing order.</li>\n</ul>\n<h5>Examples:</h5>\n<pre><code>Input: [-4,-1,0,3,10]\nOutput: [0,1,9,16,100]\n\nInput: [-7,-3,2,3,11]\nOutput: [4,9,9,49,121]\n</code></pre>\n<h3>Process:</h3>\n<ul>\n<li>\n<p>找到交界点，0左边的元素的边界i</p>\n<ul>\n<li>所有的都平方，然后把刚刚i左边的元素都插到右边</li>\n<li>一开始想是想这么做的，后来自己太菜了，所以直接平方后，排序好了</li>\n</ul>\n</li>\n</ul>\n<h3>Answer:</h3>\n<h3>Others Answer:</h3>","frontmatter":{"title":"Squares of a Sorted Array","timeSpent":40,"qId":null,"date":"2020-05-09","conquered":null,"wrongTime":null,"withHelp":null}}},{"node":{"fields":{"slug":"/learn/array-101/searching-for-items-in-an-array/check-if-n-and-its-double-exist/"},"html":"<h2>Check If N and Its Double Exist ( mins)</h2>\n<h3>Question：</h3>\n<h5>Description:</h5>\n<ul>\n<li>Given an array arr of integers, check if there exists two integers N and M such that N is the double of M ( i.e. N = 2 * M).</li>\n<li>\n<p>More formally check if there exists two indices i and j such that :</p>\n<ul>\n<li>i != j</li>\n<li>0 &#x3C;= i, j &#x3C; arr.length</li>\n<li>arr[i] == 2 * arr[j]</li>\n</ul>\n</li>\n</ul>\n<h5>Constraints:</h5>\n<ul>\n<li>2 &#x3C;= arr.length &#x3C;= 500</li>\n<li>-10^3 &#x3C;= arr[i] &#x3C;= 10^3</li>\n</ul>\n<h5>Examples:</h5>\n<pre><code>Input: arr = [10,2,5,3]\nOutput: true\nExplanation: N = 10 is the double of M = 5,that is, 10 = 2 * 5.\n\nInput: arr = [7,1,14,11]\nOutput: true\nExplanation: N = 14 is the double of M = 7,that is, 14 = 2 * 7.\n\nInput: arr = [3,1,7,11]\nOutput: false\nExplanation: In this case does not exist N and M, such that N = 2 * M.\n</code></pre>\n<h3>Process:</h3>\n<ul>\n<li>placeholder</li>\n</ul>\n<h3>Answer:</h3>\n<h3>Others Answer:</h3>","frontmatter":{"title":"Check If N and Its Double Exist","timeSpent":0,"qId":null,"date":"2020-05-09","conquered":null,"wrongTime":null,"withHelp":null}}},{"node":{"fields":{"slug":"/learn/array-101/searching-for-items-in-an-array/valid-mountain-array/"},"html":"<h2>validMountainArray (10 mins)</h2>\n<h3>Question：</h3>\n<h5>Description:</h5>\n<ul>\n<li>Given an array A of integers, return true if and only if it is a valid mountain array.</li>\n<li>\n<p>Recall that A is a mountain array if and only if:</p>\n<ul>\n<li>A.length >= 3</li>\n<li>There exists some i with 0 &#x3C; i &#x3C; A.length - 1 such that:</li>\n<li>A[0] &#x3C; A[1] &#x3C; ... A[i-1] &#x3C; A[i]</li>\n<li>A[i] > A[i+1] > ... > A[A.length - 1]</li>\n</ul>\n</li>\n<li><img src=\"https://assets.leetcode.com/uploads/2019/10/20/hint_valid_mountain_array.png\" alt=\"hint-valid-array\"></li>\n</ul>\n<h5>Note:</h5>\n<ul>\n<li>0 &#x3C;= A.length &#x3C;= 10000</li>\n<li>0 &#x3C;= A[i] &#x3C;= 10000</li>\n</ul>\n<h5>Examples:</h5>\n<pre><code>Input: [2,1]\nOutput: false\n\nInput: [3,5,5]\nOutput: false\n\nInput: [0,3,2,1]\nOutput: true\n</code></pre>\n<h3>Process:</h3>\n<ul>\n<li>找唯一的最大值</li>\n<li>线性查找</li>\n<li>不对不对，这个mountain要求连续上升，然后下降</li>\n<li>其实可以直接从定义出发，找到N个转折点，转折点超过2就挂了，或者有两个连续相等的值</li>\n</ul>\n<h3>Answer:</h3>\n<h3>Others Answer:</h3>","frontmatter":{"title":"validMountainArray","timeSpent":10,"qId":null,"date":"2020-05-09","conquered":null,"wrongTime":null,"withHelp":null}}},{"node":{"fields":{"slug":"/learn/array-101/inserting-items-into-an-array/duplicate-zeros/"},"html":"<h2>Duplicate Zeros ( mins)</h2>\n<h3>Question：</h3>\n<h5>Description:</h5>\n<ul>\n<li>Given a fixed length array arr of integers, duplicate each occurrence of zero, shifting the remaining elements to the right.</li>\n<li>Note that elements beyond the length of the original array are not written.</li>\n<li>Do the above modifications to the input array in place, do not return anything from your function.</li>\n</ul>\n<h5>Note:</h5>\n<ul>\n<li>1 &#x3C;= arr.length &#x3C;= 10000</li>\n<li>0 &#x3C;= arr[i] &#x3C;= 9</li>\n</ul>\n<h5>Examples:</h5>\n<pre><code>Input: [1,0,2,3,0,4,5,0]\nOutput: null\nExplanation: After calling your function, the input array is modified to: [1,0,0,2,3,0,0,4]\n\nInput: [1,2,3]\nOutput: null\nExplanation: After calling your function, the input array is modified to: [1,2,3]\n</code></pre>\n<h3>Process:</h3>\n<ul>\n<li>placeholder</li>\n</ul>\n<h3>Answer:</h3>\n<h3>Others Answer:</h3>","frontmatter":{"title":"Duplicate Zeros","timeSpent":0,"qId":null,"date":"2020-05-08","conquered":null,"wrongTime":null,"withHelp":null}}},{"node":{"fields":{"slug":"/learn/array-101/inserting-items-into-an-array/merge-sorted-array/"},"html":"<h2>Merge Sorted Array ( mins)</h2>\n<h3>Question：</h3>\n<h5>Description:</h5>\n<ul>\n<li>Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array.</li>\n</ul>\n<h5>Note:</h5>\n<ul>\n<li>The number of elements initialized in nums1 and nums2 are m and n respectively.</li>\n<li>You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2.</li>\n</ul>\n<h5>Examples:</h5>\n<pre><code>Input:\nnums1 = [1,2,3,0,0,0], m = 3\nnums2 = [2,5,6],       n = 3\n\nOutput: [1,2,2,3,5,6]\n</code></pre>\n<h3>Process:</h3>\n<ul>\n<li>做题目全靠猜，全靠直接执行测试</li>\n</ul>\n<h3>Answer:</h3>\n<h3>Others Answer:</h3>","frontmatter":{"title":"Merge Sorted Array","timeSpent":0,"qId":null,"date":"2020-05-08","conquered":null,"wrongTime":null,"withHelp":null}}},{"node":{"fields":{"slug":"/learn/array-101/introduction/find-numbers-with-even-number-of-digits/"},"html":"<h2>Find Numbers with Even Number of Digits ( mins)</h2>\n<h3>Question：</h3>\n<h5>Description:</h5>\n<ul>\n<li>Given an array nums of integers, return how many of them contain an even number of digits.</li>\n</ul>\n<h5>Examples:</h5>\n<pre><code>Input: nums = [12,345,2,6,7896]\nOutput: 2\nExplanation:\n12 contains 2 digits (even number of digits).\n345 contains 3 digits (odd number of digits).\n2 contains 1 digit (odd number of digits).\n6 contains 1 digit (odd number of digits).\n7896 contains 4 digits (even number of digits).\nTherefore only 12 and 7896 contain an even number of digits.\n\nInput: nums = [555,901,482,1771]\nOutput: 1\nExplanation:\nOnly 1771 contains an even number of digits.\n</code></pre>\n<h5>Constraints:</h5>\n<ul>\n<li>1 &#x3C;= nums.length &#x3C;= 500</li>\n<li>1 &#x3C;= nums[i] &#x3C;= 10^5</li>\n</ul>\n<h3>Process:</h3>\n<ul>\n<li>placeholder</li>\n</ul>\n<h3>Answer:</h3>\n<h3>Others Answer:</h3>","frontmatter":{"title":"Find Numbers with Even Number of Digits","timeSpent":0,"qId":null,"date":"2020-05-08","conquered":null,"wrongTime":null,"withHelp":null}}},{"node":{"fields":{"slug":"/learn/array-101/introduction/squares-of-a-sorted-array/"},"html":"<h2>Squares of a Sorted Array ( mins)</h2>\n<h3>Question：</h3>\n<h5>Description:</h5>\n<ul>\n<li>Given an array of integers A sorted in non-decreasing order, return an array of the squares of each number, also in sorted non-decreasing order.</li>\n</ul>\n<h5>Note:</h5>\n<ul>\n<li>1 &#x3C;= A.length &#x3C;= 10000</li>\n<li>-10000 &#x3C;= A[i] &#x3C;= 10000</li>\n<li>A is sorted in non-decreasing order.</li>\n</ul>\n<h5>Examples:</h5>\n<pre><code>Input: [-4,-1,0,3,10]\nOutput: [0,1,9,16,100]\n\nInput: [-7,-3,2,3,11]\nOutput: [4,9,9,49,121]\n</code></pre>\n<h3>Process:</h3>\n<ul>\n<li>\n<p>先做一次排序吧，如果这样的话 一开始给到的条件就没什么用了</p>\n<ul>\n<li>要想有用，可以做半个排序，也就是只负责把 &#x3C; 0 的部分插入到右边</li>\n</ul>\n</li>\n</ul>\n<h3>Answer:</h3>\n<h3>Others Answer:</h3>","frontmatter":{"title":"Squares of a Sorted Array","timeSpent":0,"qId":null,"date":"2020-05-08","conquered":null,"wrongTime":null,"withHelp":null}}},{"node":{"fields":{"slug":"/learn/array-and-string/conclusion/move-zeroes/"},"html":"<h2>Move Zeroes ( mins)</h2>\n<h3>Question：</h3>\n<h5>Description:</h5>\n<ul>\n<li>Given an array nums, write a function to move all 0's to the end of it while maintaining the relative order of the non-zero elements.</li>\n</ul>\n<h5>Note:</h5>\n<ul>\n<li>You must do this in-place without making a copy of the array.</li>\n<li>Minimize the total number of operations.</li>\n</ul>\n<h5>Examples:</h5>\n<pre><code>Input: [0,1,0,3,12]\nOutput: [1,3,12,0,0]\n</code></pre>\n<h3>Process:</h3>\n<ul>\n<li>placeholder</li>\n</ul>\n<h3>Answer:</h3>\n<h3>Others Answer:</h3>","frontmatter":{"title":"Move Zeroes","timeSpent":0,"qId":null,"date":"2020-05-07","conquered":null,"wrongTime":null,"withHelp":null}}},{"node":{"fields":{"slug":"/learn/array-and-string/conclusion/pascals-triangle-2/"},"html":"<h2>Pascal's Triangle II ( mins)</h2>\n<h3>Question：</h3>\n<h5>Description:</h5>\n<ul>\n<li>Given a non-negative index k where k ≤ 33, return the kth index row of the Pascal's triangle.</li>\n<li>Note that the row index starts from 0.</li>\n</ul>\n<h5>Note:</h5>\n<ul>\n<li>placeholder</li>\n</ul>\n<h5>Examples:</h5>\n<pre><code>Input: 3\nOutput: [1,3,3,1]\n</code></pre>\n<h3>Process:</h3>\n<ul>\n<li>不知道怎么去更好的优化它</li>\n<li>写的时候走点心，用点脑子，别想着老是debug，要人脑debug</li>\n</ul>\n<h3>Answer:</h3>\n<h3>Others Answer:</h3>","frontmatter":{"title":"Pascal's Triangle II","timeSpent":0,"qId":null,"date":"2020-05-07","conquered":null,"wrongTime":null,"withHelp":null}}},{"node":{"fields":{"slug":"/learn/array-and-string/conclusion/remove-duplicates-from-sorted-array/"},"html":"<h2>Remove Duplicates from Sorted Array (15 mins)</h2>\n<h3>Question：</h3>\n<h5>Description:</h5>\n<ul>\n<li>Given a sorted array nums, remove the duplicates in-place such that each element appear only once and return the new length.</li>\n<li>Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.</li>\n</ul>\n<h5>Clarification:</h5>\n<ul>\n<li>Confused why the returned value is an integer but your answer is an array?</li>\n<li>Note that the input array is passed in by reference, which means modification to the input array will be known to the caller as well.</li>\n<li>\n<p>Internally you can think of this:</p>\n<pre><code>// nums is passed in by reference. (i.e., without making a copy)\nint len = removeDuplicates(nums);\n</code></pre>\n</li>\n</ul>\n<p>// any modification to nums in your function would be known by the caller.\n// using the length returned by your function, it prints the first len elements.\nfor (int i = 0; i &#x3C; len; i++) {\nprint(nums[i]);\n}</p>\n<pre><code>##### Examples:\n</code></pre>\n<p>Given nums = [1,1,2],</p>\n<p>Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively.</p>\n<p>It doesn't matter what you leave beyond the returned length.</p>\n<p>Given nums = [0,0,1,1,1,2,2,3,3,4],</p>\n<p>Your function should return length = 5, with the first five elements of nums being modified to 0, 1, 2, 3, and 4 respectively.</p>\n<p>It doesn't matter what values are set beyond the returned length.</p>\n<pre><code>### Process:\n- 说说直觉\n  - sorted array 第一感觉就是binary search\n\n### Answer:\n\n### Others Answer:\n</code></pre>","frontmatter":{"title":"Remove Duplicates from Sorted Array","timeSpent":15,"qId":null,"date":"2020-05-07","conquered":null,"wrongTime":null,"withHelp":null}}},{"node":{"fields":{"slug":"/learn/array-and-string/conclusion/reverse-words-in-a-string/"},"html":"<h2>Reverse Words in a String ( mins)</h2>\n<h3>Question：</h3>\n<h5>Description:</h5>\n<ul>\n<li>Given an input string, reverse the string word by word.</li>\n</ul>\n<h5>Note:</h5>\n<ul>\n<li>A word is defined as a sequence of non-space characters.</li>\n<li>Input string may contain leading or trailing spaces. However, your reversed string should not contain leading or trailing spaces.</li>\n<li>You need to reduce multiple spaces between two words to a single space in the reversed string.</li>\n</ul>\n<h5>Examples:</h5>\n<pre><code>Input: \"the sky is blue\"\nOutput: \"blue is sky the\"\n\nInput: \"  hello world!  \"\nOutput: \"world! hello\"\nExplanation: Your reversed string should not contain leading or trailing spaces.\n\nInput: \"a good   example\"\nOutput: \"example good a\"\nExplanation: You need to reduce multiple spaces between two words to a single space in the reversed string.\n</code></pre>\n<h3>Process:</h3>\n<ul>\n<li>从尾部开始迭代，两个索引指针（快慢）</li>\n</ul>\n<h3>Answer:</h3>\n<h3>Others Answer:</h3>","frontmatter":{"title":"Reverse Words in a String","timeSpent":0,"qId":null,"date":"2020-05-07","conquered":null,"wrongTime":null,"withHelp":null}}},{"node":{"fields":{"slug":"/learn/array-and-string/conclusion/reverse-words-in-a-string-3/"},"html":"<h2>Reverse Words in a String III ( mins)</h2>\n<h3>Question：</h3>\n<h5>Description:</h5>\n<ul>\n<li>Given a string, you need to reverse the order of characters in each word within a sentence while still preserving whitespace and initial word order.</li>\n</ul>\n<h5>Note:</h5>\n<ul>\n<li>In the string, each word is separated by single space and there will not be any extra space in the string.</li>\n</ul>\n<h5>Examples:</h5>\n<pre><code>Input: \"Let's take LeetCode contest\"\nOutput: \"s'teL ekat edoCteeL tsetnoc\"\n</code></pre>\n<h3>Process:</h3>\n<ul>\n<li>placeholder</li>\n</ul>\n<h3>Answer:</h3>\n<h3>Others Answer:</h3>","frontmatter":{"title":"Reverse Words in a String III","timeSpent":0,"qId":null,"date":"2020-05-07","conquered":null,"wrongTime":null,"withHelp":null}}},{"node":{"fields":{"slug":"/learn/array-and-string/conclusion/rotate-array/"},"html":"<h2>Rotate Array (60 mins)</h2>\n<h3>Question：</h3>\n<h5>Description:</h5>\n<ul>\n<li>Given an array, rotate the array to the right by k steps, where k is non-negative.</li>\n</ul>\n<h5>Note:</h5>\n<ul>\n<li>\n<p>Follow up:</p>\n<ul>\n<li>Try to come up as many solutions as you can, there are at least 3 different ways to solve this problem.</li>\n<li>Could you do it in-place with O(1) extra space?</li>\n</ul>\n</li>\n</ul>\n<h5>Examples:</h5>\n<pre><code>Input: nums = [1,2,3,4,5,6,7], k = 3\nOutput: [5,6,7,1,2,3,4]\nExplanation:\nrotate 1 steps to the right: [7,1,2,3,4,5,6]\nrotate 2 steps to the right: [6,7,1,2,3,4,5]\nrotate 3 steps to the right: [5,6,7,1,2,3,4]\n\nInput: nums = [-1,-100,3,99], k = 2\nOutput: [3,99,-1,-100]\nExplanation:\nrotate 1 steps to the right: [99,-1,-100,3]\nrotate 2 steps to the right: [3,99,-1,-100]\n</code></pre>\n<h5>Constraints:</h5>\n<ul>\n<li>1 &#x3C;= nums.length &#x3C;= 2 * 10^4</li>\n<li>It's guaranteed that nums[i] fits in a 32 bit-signed integer.</li>\n<li>k >= 0</li>\n</ul>\n<h3>Process:</h3>\n<ul>\n<li>placeholder</li>\n</ul>\n<h3>Answer:</h3>\n<h3>Others Answer:</h3>","frontmatter":{"title":"Rotate Array","timeSpent":60,"qId":null,"date":"2020-05-06","conquered":null,"wrongTime":null,"withHelp":null}}},{"node":{"fields":{"slug":"/learn/array-and-string/array-two-pointer-technique/max-consecutive-ones/"},"html":"<h2>Max Consecutive Ones (20 mins)</h2>\n<h3>Question：</h3>\n<h5>Description:</h5>\n<ul>\n<li>Given a binary array, find the maximum number of consecutive 1s in this array.</li>\n</ul>\n<h5>Note:</h5>\n<ul>\n<li>The input array will only contain 0 and 1.</li>\n<li>The length of input array is a positive integer and will not exceed 10,000</li>\n</ul>\n<h5>Examples:</h5>\n<pre><code>Input: [1,1,0,1,1,1]\nOutput: 3\nExplanation: The first two digits or the last three digits are consecutive 1s.\n    The maximum number of consecutive 1s is 3.\n</code></pre>\n<h3>Process:</h3>\n<ul>\n<li>\n<p>one for outer iteration</p>\n<ul>\n<li>one for inner loop</li>\n</ul>\n</li>\n</ul>\n<h3>Answer:</h3>\n<h3>Others Answer:</h3>","frontmatter":{"title":"Max Consecutive Ones","timeSpent":20,"qId":485,"date":"2020-04-30","conquered":null,"wrongTime":null,"withHelp":null}}},{"node":{"fields":{"slug":"/learn/array-and-string/array-two-pointer-technique/minimum-size-subarray-sum/"},"html":"<h2>Minimum Size Subarray Sum ( mins)</h2>\n<h3>Question：</h3>\n<h5>Description:</h5>\n<ul>\n<li>Given an array of n positive integers and a positive integer s, find the minimal length of a contiguous subarray of which the sum ≥ s. If there isn't one, return 0 instead.</li>\n</ul>\n<h5>Note:</h5>\n<ul>\n<li>If you have figured out the O(n) solution, try coding another solution of which the time complexity is O(n log n).</li>\n</ul>\n<h5>Examples:</h5>\n<pre><code>Input: s = 7, nums = [2,3,1,2,4,3]\nOutput: 2\nExplanation: the subarray [4,3] has the minimal length under the problem constraint.\n</code></pre>\n<h3>Process:</h3>\n<ul>\n<li>O(n ^ 3) 挂了</li>\n<li>思考思考数学问题，因为算法很多时候跟数学问题息息相关</li>\n<li>\n<p>看了题解</p>\n<ul>\n<li>有点神奇</li>\n<li>总结一下：</li>\n<li>利用的一点就是 迭代累加，如果加上这个<strong>刚好</strong>大于等于s，那么子数组一定是包含当前元素的。</li>\n<li>然后从子数组签名剔除元素，直到不再 >= s</li>\n</ul>\n</li>\n</ul>\n<h3>Answer:</h3>\n<h3>Others Answer:</h3>","frontmatter":{"title":"Minimum Size Subarray Sum","timeSpent":100,"qId":null,"date":"2020-04-30","conquered":null,"wrongTime":null,"withHelp":null}}},{"node":{"fields":{"slug":"/learn/array-and-string/array-two-pointer-technique/remove-element/"},"html":"<h2>Remove Element ( mins)</h2>\n<h3>Question：</h3>\n<h5>Description:</h5>\n<ul>\n<li>Given an array nums and a value val, remove all instances of that value <strong>in-place</strong> and return the new length.</li>\n<li>Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.</li>\n<li>The order of elements can be changed. It doesn't matter what you leave beyond the new length.</li>\n</ul>\n<h5>Clarification:</h5>\n<ul>\n<li>Confused why the returned value is an integer but your answer is an array?</li>\n<li>Note that the input array is passed in by reference, which means modification to the input array will be known to the caller as well.</li>\n<li>\n<p>Internally you can think of this:</p>\n<pre><code>// nums is passed in by reference. (i.e., without making a copy)\nint len = removeElement(nums, val);\n\n// any modification to nums in your function would be known by the caller.\n// using the length returned by your function, it prints the first len elements.\nfor (int i = 0; i &#x3C; len; i++) {\n  print(nums[i]);\n}\n</code></pre>\n</li>\n</ul>\n<h5>Examples:</h5>\n<pre><code>Given nums = [3,2,2,3], val = 3,\n\n// Your function should return length = 2, with the first two elements of nums being 2.\n\n// It doesn't matter what you leave beyond the returned length.\n\nGiven nums = [0,1,2,2,3,0,4,2], val = 2,\n\nYour function should return length = 5, with the first five elements of nums containing 0, 1, 3, 0, and 4.\n\nNote that the order of those five elements can be arbitrary.\n\nIt doesn't matter what values are set beyond the returned length.\n</code></pre>\n<h3>Process:</h3>\n<ul>\n<li>So stupid question description...</li>\n<li>just modify the input array and return the length</li>\n<li>\n<p>use two pointer</p>\n<ul>\n<li>one for iteration</li>\n<li>one be placed in the end (always keep elements after second pointer is the target val)</li>\n<li>if current iteration value if the target value, just swap it with second pointer</li>\n</ul>\n</li>\n<li>\n<p>实际做的时候还是遇到了一些问题了，这道题一共卡了80分钟。。。本来状态就不好，\n其中有一个判断条件是 右边指针--，需要一个while循环去减减，这样才服务和哦我们的想法</p>\n<ul>\n<li>右边的指针代表：下一个要被替换的元素，在他右边的都是 === val的</li>\n</ul>\n</li>\n</ul>\n<h3>Answer:</h3>\n<h3>Others Answer:</h3>","frontmatter":{"title":"Remove Element","timeSpent":80,"qId":null,"date":"2020-04-30","conquered":null,"wrongTime":null,"withHelp":null}}},{"node":{"fields":{"slug":"/learn/array-and-string/array-two-pointer-technique/reverse-string/"},"html":"<h2>Reverse String (6 mins)</h2>\n<h3>Question：</h3>\n<h5>Description:</h5>\n<ul>\n<li>Write a function that reverses a string. The input string is given as an array of characters char[].</li>\n<li>Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.</li>\n<li>You may assume all the characters consist of printable ascii characters.</li>\n</ul>\n<h5>Note:</h5>\n<ul>\n<li>placeholder</li>\n</ul>\n<h5>Examples:</h5>\n<pre><code>Input: [\"h\",\"e\",\"l\",\"l\",\"o\"]\nOutput: [\"o\",\"l\",\"l\",\"e\",\"h\"]\n\nInput: [\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"]\nOutput: [\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"]\n</code></pre>\n<h3>Process:</h3>\n<ul>\n<li>如题</li>\n</ul>\n<h3>Answer:</h3>\n<h3>Others Answer:</h3>","frontmatter":{"title":"Reverse String","timeSpent":null,"qId":null,"date":"2020-04-29","conquered":null,"wrongTime":null,"withHelp":null}}},{"node":{"fields":{"slug":"/learn/array-and-string/array-two-pointer-technique/two-sum-2-input-array-sorted/"},"html":"<h2>twoSum (20 mins)</h2>\n<h3>Question：</h3>\n<h5>Description:</h5>\n<ul>\n<li>Given an array of integers that is already sorted in ascending order, find two numbers such that they add up to a specific target number.</li>\n<li>The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2.</li>\n</ul>\n<h5>Note:</h5>\n<ul>\n<li>Your returned answers (both index1 and index2) are not zero-based.</li>\n<li>You may assume that each input would have exactly one solution and you may not use the same element twice.</li>\n</ul>\n<h5>Examples:</h5>\n<pre><code>Input: numbers = [2,7,11,15], target = 9\nOutput: [1,2]\nExplanation: The sum of 2 and 7 is 9. Therefore index1 = 1, index2 = 2.\n</code></pre>\n<h3>Process:</h3>\n<ul>\n<li>there is no assumption that the number is position so that we can filter some elements larger than target</li>\n<li>keep in mind that we should use two pointer technique</li>\n<li>\n<p>In the out loop, we can fix one number and calc the rest number by substract from target.</p>\n<ul>\n<li>use another pointer to check</li>\n</ul>\n</li>\n<li>complexity is O(n^2) i think</li>\n</ul>\n<h3>Answer:</h3>\n<h3>Others Answer:</h3>","frontmatter":{"title":"Two Sum II - Input array is sorted","timeSpent":0,"qId":null,"date":"2020-04-29","conquered":null,"wrongTime":null,"withHelp":null}}},{"node":{"fields":{"slug":"/learn/array-and-string/array-two-pointer-technique/array-partition-1/"},"html":"<h2>Array Partition I ( mins)</h2>\n<h3>Question：</h3>\n<h5>Description:</h5>\n<ul>\n<li>Given an array of 2n integers, your task is to group these integers into n pairs of integer, say (a1, b1), (a2, b2), ..., (an, bn) which makes sum of min(ai, bi) for all i from 1 to n as large as possible.</li>\n</ul>\n<h5>Note:</h5>\n<ul>\n<li>n is a positive integer, which is in the range of [1, 10000].</li>\n<li>All the integers in the array will be in the range of [-10000, 10000].</li>\n</ul>\n<h5>Examples:</h5>\n<pre><code>Input: [1,4,3,2]\n\nOutput: 4\nExplanation: n is 2, and the maximum sum of pairs is 4 = min(1, 2) + min(3, 4).\n</code></pre>\n<h3>Process:</h3>\n<ul>\n<li>we need a sort algorithm to sort the array</li>\n<li>then we just calc the sum of array skipping the even index</li>\n<li>use two pointer tech to remove the complexity.</li>\n</ul>\n<h3>Answer:</h3>\n<h3>Others Answer:</h3>","frontmatter":{"title":"Array Partition I","timeSpent":13,"qId":null,"date":"2020-04-29","conquered":null,"wrongTime":null,"withHelp":null}}},{"node":{"fields":{"slug":"/learn/array-and-string/introduction-to-string/add-binary/"},"html":"<h2>Add Binary (25 mins)</h2>\n<h3>Question：</h3>\n<h5>Description:</h5>\n<ul>\n<li>Given two binary strings, return their sum (also a binary string).</li>\n<li>The input strings are both non-empty and contains only characters 1 or 0.</li>\n</ul>\n<h5>Constraints:</h5>\n<ul>\n<li>Each string consists only of '0' or '1' characters.</li>\n<li>1 &#x3C;= a.length, b.length &#x3C;= 10^4</li>\n<li>Each string is either \"0\" or doesn't contain any leading zero.</li>\n</ul>\n<h5>Examples:</h5>\n<pre><code>Input: a = \"11\", b = \"1\"\nOutput: \"100\"\n\nInput: a = \"1010\", b = \"1011\"\nOutput: \"10101\"\n</code></pre>\n<h3>Process:</h3>\n<ul>\n<li>convert the input string into two arrays</li>\n<li>add digit by digit starting by the last index and index--</li>\n</ul>\n<h3>Answer:</h3>\n<h3>Others Answer:</h3>","frontmatter":{"title":"Add Binary","timeSpent":null,"qId":null,"date":"2020-04-28","conquered":null,"wrongTime":null,"withHelp":null}}},{"node":{"fields":{"slug":"/learn/array-and-string/introduction-to-string/implement-strstr-method/"},"html":"<h2>Implement strStr() (20 mins)</h2>\n<h3>Question：</h3>\n<h5>Description:</h5>\n<ul>\n<li>Implement <a href=\"http://www.cplusplus.com/reference/cstring/strstr/\">strStr()</a>.</li>\n<li>Return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.</li>\n</ul>\n<h5>Clarification:</h5>\n<ul>\n<li>What should we return when needle is an empty string? This is a great question to ask during an interview.</li>\n<li>For the purpose of this problem, we will return 0 when needle is an empty string. This is consistent to C's strstr() and Java's indexOf().</li>\n</ul>\n<h5>Examples:</h5>\n<pre><code>Input: haystack = \"hello\", needle = \"ll\"\nOutput: 2\n\nInput: haystack = \"aaaaa\", needle = \"bba\"\nOutput: -1\n</code></pre>\n<h3>Process:</h3>\n<ul>\n<li>convert the input string into array</li>\n<li>use a simple for loop the check whether equality</li>\n<li>complexity is O(n)</li>\n</ul>\n<h3>Answer:</h3>\n<h3>Others Answer:</h3>","frontmatter":{"title":"Implement strStr()","timeSpent":null,"qId":null,"date":"2020-04-28","conquered":null,"wrongTime":null,"withHelp":null}}},{"node":{"fields":{"slug":"/learn/array-and-string/introduction-to-string/longest-common-prefix/"},"html":"<h2>Longest Common Prefix ( mins)</h2>\n<h3>Question：</h3>\n<h5>Description:</h5>\n<ul>\n<li>Write a function to find the longest common prefix string amongst an array of strings.</li>\n<li>If there is no common prefix, return an empty string \"\".</li>\n</ul>\n<h5>Note:</h5>\n<ul>\n<li>All given inputs are in lowercase letters a-z.</li>\n</ul>\n<h5>Examples:</h5>\n<pre><code>Input: [\"flower\",\"flow\",\"flight\"]\nOutput: \"fl\"\n\nInput: [\"dog\",\"racecar\",\"car\"]\nOutput: \"\"\nExplanation: There is no common prefix among the input strings.\n</code></pre>\n<h3>Process:</h3>\n<ul>\n<li>use a for loop whose index string from 0, and ++ the index</li>\n<li>if not equal, break the loop</li>\n</ul>\n<h3>Answer:</h3>\n<h3>Others Answer:</h3>","frontmatter":{"title":"Longest Common Prefix","timeSpent":null,"qId":null,"date":"2020-04-28","conquered":null,"wrongTime":null,"withHelp":null}}},{"node":{"fields":{"slug":"/learn/array-and-string/introduction-to-2d-array/diagonal-traverse/"},"html":"<h2>Diagonal Traverse (50 mins)</h2>\n<h3>Question：</h3>\n<h5>Description:</h5>\n<ul>\n<li>Given a matrix of M x N elements (M rows, N columns), return all elements of the matrix in diagonal order as shown in the below image.</li>\n</ul>\n<h5>Note:</h5>\n<ul>\n<li>placeholder</li>\n</ul>\n<h5>Examples:</h5>\n<pre><code>Input:\n[\n [ 1, 2, 3 ],\n [ 4, 5, 6 ],\n [ 7, 8, 9 ]\n]\n\nOutput:  [1,2,4,7,5,3,6,8,9]\n</code></pre>\n<h3>Process:</h3>\n<ul>\n<li>O(n^2) method</li>\n<li>calc the max(M, N)</li>\n<li>\n<p>rules (check in the boundary of array before, so that other lang except js won't throw error)</p>\n<ul>\n<li>even  (0, 0)</li>\n<li>odd (1, 0) (0, 1)</li>\n<li>even  (0, 2) (1, 1) (2, 0)</li>\n<li>odd (3, 0) (2, 1) (1, 2) (0, 3)</li>\n</ul>\n</li>\n</ul>\n<h3>Answer:</h3>\n<h3>Others Answer:</h3>","frontmatter":{"title":"Diagonal Traverse","timeSpent":null,"qId":null,"date":"2020-04-27","conquered":null,"wrongTime":null,"withHelp":null}}},{"node":{"fields":{"slug":"/learn/array-and-string/introduction-to-2d-array/pascal-triangle/"},"html":"<h2>Pascal's Triangle (30 mins)</h2>\n<h3>Question：</h3>\n<h5>Description:</h5>\n<ul>\n<li>Given a non-negative integer numRows, generate the first numRows of Pascal's triangle.</li>\n</ul>\n<h5>Note:</h5>\n<ul>\n<li>placeholder</li>\n</ul>\n<h5>Examples:</h5>\n<pre><code>Input: 5\nOutput:\n[\n     [1],\n    [1,1],\n   [1,2,1],\n  [1,3,3,1],\n [1,4,6,4,1]\n]\n</code></pre>\n<h3>Process:</h3>\n<ul>\n<li>\n<p>O(n^2) method</p>\n<ul>\n<li>calc each row using a nested loop</li>\n</ul>\n</li>\n<li>\n<p>more advanced method</p>\n<ul>\n<li>maybe there is a formulae</li>\n</ul>\n</li>\n</ul>\n<h3>Answer:</h3>\n<h3>Others Answer:</h3>","frontmatter":{"title":"Pascal's Triangle","timeSpent":null,"qId":null,"date":"2020-04-27","conquered":null,"wrongTime":null,"withHelp":null}}},{"node":{"fields":{"slug":"/learn/array-and-string/introduction-to-2d-array/spiral-matrix/"},"html":"<h2>Spiral Matrix (55 mins)</h2>\n<h3>Question：</h3>\n<h5>Description:</h5>\n<ul>\n<li>Given a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order.</li>\n</ul>\n<h5>Note:</h5>\n<ul>\n<li>placeholder</li>\n</ul>\n<h5>Examples:</h5>\n<pre><code>Input:\n[\n [ 1, 2, 3 ],\n [ 4, 5, 6 ],\n [ 7, 8, 9 ]\n]\nOutput: [1,2,3,6,9,8,7,4,5]\n\nInput:\n[\n  [1, 2, 3, 4],\n  [5, 6, 7, 8],\n  [9,10,11,12]\n]\nOutput: [1,2,3,4,8,12,11,10,9,5,6,7]\n</code></pre>\n<h3>Process:</h3>\n<ul>\n<li>use a variable to record direction( (0,1,2,3) % 4 ) means four direction, selfAdd if exceed the boundary</li>\n<li>use i,j to loop</li>\n<li>after seeing hints of that problems by others, a more space saving method is maybe keep track of the row/col that have been scaned.</li>\n</ul>\n<h3>Answer:</h3>\n<h3>Others Answer:</h3>","frontmatter":{"title":"Spiral Matrix","timeSpent":null,"qId":null,"date":"2020-04-27","conquered":null,"wrongTime":null,"withHelp":null}}},{"node":{"fields":{"slug":"/learn/array-and-string/introduction-to-array/find-pivot-index/"},"html":"<h2>pivotIndex (30 mins)</h2>\n<h3>Question：</h3>\n<h5>Description:</h5>\n<ul>\n<li>Given an array of integers nums, write a method that returns the \"pivot\" index of this array.</li>\n<li>We define the pivot index as the index where the sum of the numbers to the left of the index is equal to the sum of the numbers to the right of the index.</li>\n<li>If no such index exists, we should return -1. If there are multiple pivot indexes, you should return the left-most pivot index.</li>\n</ul>\n<h5>Note:</h5>\n<ul>\n<li>The length of nums will be in the range [0, 10000].</li>\n<li>Each element nums[i] will be an integer in the range [-1000, 1000].</li>\n</ul>\n<h5>Examples:</h5>\n<pre><code>Input:\nnums = [1, 7, 3, 6, 5, 6]\nOutput: 3\nExplanation:\nThe sum of the numbers to the left of index 3 (nums[3] = 6) is equal to the sum of numbers to the right of index 3.\nAlso, 3 is the first index where this occurs.\n\nInput:\nnums = [1, 2, 3]\nOutput: -1\nExplanation:\nThere is no index that satisfies the conditions in the problem statement.\n</code></pre>\n<h3>Process:</h3>\n<ul>\n<li>\n<p>O(n^2) solution(direct solution):</p>\n<ul>\n<li>iterate the given array, calc sum of numbers to the left and sum of numbers to the right</li>\n<li>if match the condition, then return it.</li>\n<li>because we iterate from left to right, so the first will be pivot</li>\n</ul>\n</li>\n<li>\n<p>O(n)</p>\n<ul>\n<li>can we record something more during loop, so that we won't calc the sum every time</li>\n<li>yes we can</li>\n<li>we need pre-calc the sum of all items in the array</li>\n<li>\n<p>then in another non-nested for-loop</p>\n<ul>\n<li>for the first item, we know the left is 0, right to current item is the sum subtract current item</li>\n<li>we store the left in an temp variable</li>\n<li>the rest item, we just need add variable and prev-item so that we can know the left sum</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3>Answer:</h3>\n<h3>Others Answer:</h3>","frontmatter":{"title":"Find Pivot Index","timeSpent":null,"qId":null,"date":"2020-04-26","conquered":null,"wrongTime":null,"withHelp":null}}},{"node":{"fields":{"slug":"/learn/array-and-string/introduction-to-array/largest-number-at-least-twice-of-others/"},"html":"<h2>Largest Number At Least Twice of Others (22 mins)</h2>\n<h3>Question：</h3>\n<h5>Description:</h5>\n<ul>\n<li>In a given integer array nums, there is always exactly one largest element.</li>\n<li>Find whether the largest element in the array is at least twice as much as every other number in the array.</li>\n<li>If it is, return the index of the largest element, otherwise return -1.</li>\n</ul>\n<h5>Note:</h5>\n<ul>\n<li>nums will have a length in the range [1, 50].</li>\n<li>Every nums[i] will be an integer in the range [0, 99].</li>\n</ul>\n<h5>Examples:</h5>\n<pre><code>Input: nums = [3, 6, 1, 0]\nOutput: 1\nExplanation: 6 is the largest integer, and for every other number in the array x,\n6 is more than twice as big as x.  The index of value 6 is 1, so we return 1.\n\nInput: nums = [1, 2, 3, 4]\nOutput: -1\nExplanation: 4 isn't at least as big as twice the value of 3, so we return -1.\n</code></pre>\n<h3>Process:</h3>\n<ul>\n<li>\n<p>direct method O(n)</p>\n<ul>\n<li>iterate the input array</li>\n<li>get the max one, record the index of that number</li>\n<li>calc the twice of each item and store it in another array</li>\n<li>iterate the other array, check the item is larger than ...</li>\n</ul>\n</li>\n</ul>\n<h3>Answer:</h3>\n<h3>Others Answer:</h3>","frontmatter":{"title":"Largest Number At Least Twice of Others","timeSpent":null,"qId":null,"date":"2020-04-26","conquered":null,"wrongTime":null,"withHelp":null}}},{"node":{"fields":{"slug":"/learn/array-and-string/introduction-to-array/plus-one/"},"html":"<h2>Plus One (20 mins)</h2>\n<h3>Question：</h3>\n<h5>Description:</h5>\n<ul>\n<li>Given a non-empty array of digits representing a non-negative integer, plus one to the integer.</li>\n<li>The digits are stored such that the most significant digit is at the head of the list, and each element in the array contain a single digit.</li>\n<li>You may assume the integer does not contain any leading zero, except the number 0 itself.</li>\n</ul>\n<h5>Note:</h5>\n<ul>\n<li>placeholder</li>\n</ul>\n<h5>Examples:</h5>\n<pre><code>Input: [1,2,3]\nOutput: [1,2,4]\nExplanation: The array represents the integer 123.\n\nInput: [4,3,2,1]\nOutput: [4,3,2,2]\nExplanation: The array represents the integer 4321.\n</code></pre>\n<h3>Process:</h3>\n<ul>\n<li>Just like Big Int Plus one, we need carry bit in the array.</li>\n</ul>\n<h3>Answer:</h3>\n<h3>Others Answer:</h3>","frontmatter":{"title":"Plus One","timeSpent":null,"qId":null,"date":"2020-04-26","conquered":null,"wrongTime":null,"withHelp":null}}},{"node":{"fields":{"slug":"/30days-challenge/week2/perform-string-shifts/"},"html":"<h2>Perform String Shifts ( mins)</h2>\n<h3>Question：</h3>\n<h5>Description:</h5>\n<ul>\n<li>You are given a string s containing lowercase English letters, and a matrix shift, where shift[i] = [direction, amount]:</li>\n<li>direction can be 0 (for left shift) or 1 (for right shift).</li>\n<li>amount is the amount by which string s is to be shifted.</li>\n<li>A left shift by 1 means remove the first character of s and append it to the end.</li>\n<li>Similarly, a right shift by 1 means remove the last character of s and add it to the beginning.</li>\n<li>Return the final string after all operations.</li>\n</ul>\n<h5>Constraints:</h5>\n<ul>\n<li>1 &#x3C;= s.length &#x3C;= 100</li>\n<li>s only contains lower case English letters.</li>\n<li>1 &#x3C;= shift.length &#x3C;= 100</li>\n<li>shift[i].length == 2</li>\n<li>0 &#x3C;= shift[i][0] &#x3C;= 1</li>\n<li>0 &#x3C;= shift[i][1] &#x3C;= 100</li>\n</ul>\n<h5>Examples:</h5>\n<pre><code>Input: s = \"abc\", shift = [[0,1],[1,2]]\nOutput: \"cab\"\nExplanation:\n[0,1] means shift to left by 1. \"abc\" -> \"bca\"\n[1,2] means shift to right by 2. \"bca\" -> \"cab\"\n\nInput: s = \"abcdefg\", shift = [[1,1],[1,1],[0,2],[1,3]]\nOutput: \"efgabcd\"\nExplanation:\n[1,1] means shift to right by 1. \"abcdefg\" -> \"gabcdef\"\n[1,1] means shift to right by 1. \"gabcdef\" -> \"fgabcde\"\n[0,2] means shift to left by 2. \"fgabcde\" -> \"abcdefg\"\n[1,3] means shift to right by 3. \"abcdefg\" -> \"efgabcd\"\n</code></pre>\n<h3>Process:</h3>\n<ul>\n<li>一不小心看到了 hints</li>\n<li>左右可以抵消。。。😂</li>\n</ul>\n<h3>Answer:</h3>\n<h3>Others Answer:</h3>","frontmatter":{"title":"Perform String Shifts","timeSpent":null,"qId":null,"date":"2020-04-20","conquered":null,"wrongTime":null,"withHelp":null}}},{"node":{"fields":{"slug":"/contest/0418/get-coin/"},"html":"<h2>minCount ( mins)</h2>\n<h3>Question：</h3>\n<h5>Description:</h5>\n<ul>\n<li>桌上有 n 堆力扣币，每堆的数量保存在数组 coins 中。我们每次可以选择任意一堆，拿走其中的一枚或者两枚，求拿完所有力扣币的最少次数。</li>\n</ul>\n<h5>LIMIT:</h5>\n<ul>\n<li>1 &#x3C;= n &#x3C;= 4</li>\n<li>1 &#x3C;= coins[i] &#x3C;= 10</li>\n</ul>\n<h5>Examples:</h5>\n<pre><code>输入：[4,2,1]\n\n输出：4\n\n解释：第一堆力扣币最少需要拿 2 次，第二堆最少需要拿 1 次，第三堆最少需要拿 1 次，总共 4 次即可拿完。\n</code></pre>\n<h3>Process:</h3>\n<ul>\n<li>placeholder</li>\n</ul>\n<h3>Answer:</h3>\n<h3>Others Answer:</h3>","frontmatter":{"title":"minCount","timeSpent":null,"qId":null,"date":"2020-04-18","conquered":null,"wrongTime":null,"withHelp":null}}},{"node":{"fields":{"slug":"/contest/0418/opera-time/"},"html":"<h2>getTriggerTime ( mins)</h2>\n<h3>Question：</h3>\n<h5>Description:</h5>\n<ul>\n<li>placeholder</li>\n</ul>\n<h5>Note:</h5>\n<ul>\n<li>placeholder</li>\n</ul>\n<h5>Examples:</h5>\n<pre><code>placeholder\n</code></pre>\n<h3>Process:</h3>\n<ul>\n<li>placeholder</li>\n</ul>\n<h3>Answer:</h3>\n<h3>Others Answer:</h3>","frontmatter":{"title":"getTriggerTime","timeSpent":null,"qId":null,"date":"2020-04-18","conquered":null,"wrongTime":null,"withHelp":null}}},{"node":{"fields":{"slug":"/contest/0418/pass-info/"},"html":"<h2>numWays ( mins)</h2>\n<h3>Question：</h3>\n<h5>Description:</h5>\n<ul>\n<li>小朋友 A 在和 ta 的小伙伴们玩传信息游戏，游戏规则如下：</li>\n<li>有 n 名玩家，所有玩家编号分别为 0 ～ n-1，其中小朋友 A 的编号为 0</li>\n<li>每个玩家都有固定的若干个可传信息的其他玩家（也可能没有）。传信息的关系是单向的（比如 A 可以向 B 传信息，但 B 不能向 A 传信息）。</li>\n<li>每轮信息必须需要传递给另一个人，且信息可重复经过同一个人</li>\n<li>给定总玩家数 n，以及按 [玩家编号,对应可传递玩家编号] 关系组成的二维数组 relation。返回信息从小 A (编号 0 ) 经过 k 轮传递到编号为 n-1 的小伙伴处的方案数；若不能到达，返回 0。</li>\n</ul>\n<h5>Note:</h5>\n<ul>\n<li>2 &#x3C;= n &#x3C;= 10</li>\n<li>1 &#x3C;= k &#x3C;= 5</li>\n<li>1 &#x3C;= relation.length &#x3C;= 90, 且 relation[i].length == 2</li>\n<li>0 &#x3C;= relation[i][0],relation[i][1] &#x3C; n 且 relation[i][0] != relation[i][1]</li>\n</ul>\n<h5>Examples:</h5>\n<pre><code>输入：n = 5, relation = [[0,2],[2,1],[3,4],[2,3],[1,4],[2,0],[0,4]], k = 3\n\n输出：3\n\n解释：信息从小 A 编号 0 处开始，经 3 轮传递，到达编号 4。共有 3 种方案，分别是 0->2->0->4， 0->2->1->4， 0->2->3->4。\n\n输入：n = 3, relation = [[0,2],[2,1]], k = 2\n\n输出：0\n\n解释：信息不能从小 A 处经过 2 轮传递到编号 2\n</code></pre>\n<h3>Process:</h3>\n<ul>\n<li>这是 一个图，或者说 是一个状态机，怎么处理</li>\n<li>这又是一个 可以拆分的子问题</li>\n</ul>\n<h3>Answer:</h3>\n<h3>Others Answer:</h3>","frontmatter":{"title":"numWays","timeSpent":null,"qId":null,"date":"2020-04-18","conquered":null,"wrongTime":null,"withHelp":null}}},{"node":{"fields":{"slug":"/30days-challenge/week2/product-except-self/"},"html":"<h2>productExceptSelf (20 mins)</h2>\n<h3>Question：</h3>\n<h5>Description:</h5>\n<ul>\n<li>Given an array nums of n integers where n > 1,  return an array output such that output[i] is equal to the product of all the elements of nums except nums[i].</li>\n</ul>\n<h5>Constraint:</h5>\n<ul>\n<li>It's guaranteed that the product of the elements of any prefix or suffix of the array (including the whole array) fits in a 32 bit integer.</li>\n</ul>\n<h5>Note:</h5>\n<ul>\n<li>Please solve it without division and in O(n).</li>\n</ul>\n<h5>Follow up:</h5>\n<ul>\n<li>Could you solve it with constant space complexity? (The output array does not count as extra space for the purpose of space complexity analysis.)</li>\n</ul>\n<h5>Examples:</h5>\n<pre><code>Input:  [1,2,3,4]\nOutput: [24,12,8,6]\n</code></pre>\n<h3>Process:</h3>\n<ul>\n<li>[1] => [1]</li>\n<li>[1,2] => [2,1]</li>\n<li>[1,2,3] => [2<em>3,1</em>3,1*2]</li>\n<li>[1,2,3,4] => [2<em>3</em>4,1<em>3</em>4,1<em>2</em>4,1<em>2</em>3]</li>\n<li>写着写着 发现不是O(n)...</li>\n<li>虽然通过了，有必要在研究下 的</li>\n</ul>\n<h3>Answer:</h3>\n<h3>Others Answer:</h3>","frontmatter":{"title":"productExceptSelf","timeSpent":null,"qId":null,"date":"2020-04-16","conquered":null,"wrongTime":null,"withHelp":null}}},{"node":{"fields":{"slug":"/30days-challenge/week2/contiguous-array/"},"html":"<h2>Contiguous Array (50 mins)</h2>\n<h3>Question：</h3>\n<h5>Description:</h5>\n<ul>\n<li>Given a binary array, find the maximum length of a contiguous subarray with equal number of 0 and 1.</li>\n</ul>\n<h5>Note:</h5>\n<ul>\n<li>The length of the given binary array will not exceed 50,000.</li>\n</ul>\n<h5>Examples:</h5>\n<pre><code>Input: [0,1]\nOutput: 2\nExplanation: [0, 1] is the longest contiguous subarray with equal number of 0 and 1.\n\nInput: [0,1,0]\nOutput: 2\nExplanation: [0, 1] (or [1, 0]) is a longest contiguous subarray with equal number of 0 and 1.\n</code></pre>\n<h3>Process:</h3>\n<ul>\n<li>首先 第一次题目理解错了，以为 连续的01/10的数量</li>\n<li>其实 应该是 00001111，也算</li>\n<li>\n<p>能不能遍历数组，记录一遍每个节点的信息</p>\n<ul>\n<li>[0, 1, 0, 0, 0, 1, 1]</li>\n<li>=></li>\n<li>0: {0: 1, 1: 0}</li>\n<li>1: {0: 1, 1: 1}</li>\n<li>0: {0: 2, 1: 1}</li>\n<li>0: {0: 3, 1: 1}</li>\n<li>0: {0: 4, 1: 1}</li>\n<li>1: {0: 4, 1: 2}</li>\n<li>1: {0: 4, 1: 3}</li>\n</ul>\n</li>\n<li>感觉上面的解法挺有意思，但是怎么证明他是对的呢？怎么证明连续的一组数据就是正确的呢</li>\n<li>[0,1,1,0,1,1,1,0] 这个数组 证明，我的方法是错的， 没有连续。</li>\n<li>确实哦，我这个没有判断连续，那么如何包含这种情况呢</li>\n<li>我的结论是这样基本是错的，又不是让你找从数组的一开始，有多少个同样的0、1，没必要保留从0开始的有多少个0，1</li>\n<li><strong>动态规划，len每增加一，当前最优解，要么是不用新增的值，要么是使用新增的值</strong></li>\n<li>没用动态规划想出来，大佬也没有嘿嘿嘿</li>\n<li>我想到 每个节点 保存 已经有的0和1的值了，</li>\n<li>但是 最后判断结果的一步错了，应该是 0和1个数相等的点是平衡点，两个平衡点之间0，1的个数一定是相等的，所以返回的就是最大的两个平衡点的距离</li>\n<li>平衡点 不一定是 0、1个数相等的点，</li>\n<li>而是 每个节点累计 0，1计算下来，画出这样一条线，y值相等的点之间的最远距离就是结果</li>\n<li>开心，豁然开朗</li>\n</ul>\n<h3>Answer:</h3>\n<h3>Others Answer:</h3>","frontmatter":{"title":" Contiguous Array","timeSpent":null,"qId":null,"date":"2020-04-14","conquered":null,"wrongTime":null,"withHelp":null}}},{"node":{"fields":{"slug":"/30days-challenge/week2/diameter-of-binary-tree/"},"html":"<h2>diameterOfBinaryTree ( mins)</h2>\n<h3>Question：</h3>\n<h5>Description:</h5>\n<ul>\n<li>Given a binary tree, you need to compute the length of the diameter of the tree. The diameter of a binary tree is the length of the longest path between any two nodes in a tree. This path may or may not pass through the root.</li>\n</ul>\n<h5>Note:</h5>\n<ul>\n<li>The length of path between two nodes is represented by the number of edges between them.</li>\n</ul>\n<h5>Examples:</h5>\n<pre><code>          1\n         / \\\n        2   3\n       / \\\n      4   5\n\nReturn 3, which is the length of the path [4,2,1,3] or [5,2,1,3].\n</code></pre>\n<h3>Process:</h3>\n<ul>\n<li>placeholder</li>\n</ul>\n<h3>Answer:</h3>\n<h3>Others Answer:</h3>","frontmatter":{"title":"diameterOfBinaryTree","timeSpent":null,"qId":null,"date":"2020-04-14","conquered":null,"wrongTime":null,"withHelp":null}}},{"node":{"fields":{"slug":"/30days-challenge/week2/last-stone-weight/"},"html":"<h2>lastStoneWeight (30 mins)</h2>\n<h3>Question：</h3>\n<h5>Description:</h5>\n<ul>\n<li>We have a collection of stones, each stone has a positive integer weight.</li>\n<li>\n<p>Each turn, we choose the two heaviest stones and smash them together.  Suppose the stones have weights x and y with x &#x3C;= y.  The result of this smash is:</p>\n<ul>\n<li>If x == y, both stones are totally destroyed;</li>\n<li>If x != y, the stone of weight x is totally destroyed, and the stone of weight y has new weight y-x.</li>\n<li>At the end, there is at most 1 stone left.  Return the weight of this stone (or 0 if there are no stones left.)</li>\n</ul>\n</li>\n</ul>\n<h5>Note:</h5>\n<ul>\n<li>1 &#x3C;= stones.length &#x3C;= 30</li>\n<li>1 &#x3C;= stones[i] &#x3C;= 1000</li>\n</ul>\n<h5>Examples:</h5>\n<pre><code>Input: [2,7,4,1,8,1]\nOutput: 1\nExplanation:\nWe combine 7 and 8 to get 1 so the array converts to [2,4,1,1,1] then,\nwe combine 2 and 4 to get 2 so the array converts to [2,1,1,1] then,\nwe combine 2 and 1 to get 1 so the array converts to [1,1,1] then,\nwe combine 1 and 1 to get 0 so the array converts to [1] then that's the value of last stone.\n</code></pre>\n<h3>Process:</h3>\n<ul>\n<li>原以为大家都会自己写一个排序的，谁知道 都用了sort hhh</li>\n</ul>\n<h3>Answer:</h3>\n<h3>Others Answer:</h3>","frontmatter":{"title":"lastStoneWeight","timeSpent":null,"qId":null,"date":"2020-04-13","conquered":null,"wrongTime":null,"withHelp":null}}},{"node":{"fields":{"slug":"/30days-challenge/week2/min-stack/"},"html":"<h2>MinStack ( mins)</h2>\n<h3>Question：</h3>\n<h5>Description:</h5>\n<ul>\n<li>Design a stack that supports <code>push, pop, top, and retrieving the minimum element</code> in <strong>constant</strong> time.</li>\n<li>\n<p>functionality</p>\n<ul>\n<li>push(x) -- Push element x onto stack.</li>\n<li>pop() -- Removes the element on top of the stack.</li>\n<li>top() -- Get the top element.</li>\n<li>getMin() -- Retrieve the minimum element in the stack.</li>\n</ul>\n</li>\n</ul>\n<h5>Hite:</h5>\n<ul>\n<li>Consider each node in the stack having a minimum value. (Credits to @aakarshmadhavan)</li>\n</ul>\n<h5>Examples:</h5>\n<pre><code>MinStack minStack = new MinStack();\nminStack.push(-2);\nminStack.push(0);\nminStack.push(-3);\nminStack.getMin();   --> Returns -3.\nminStack.pop();\nminStack.top();      --> Returns 0.\nminStack.getMin();   --> Returns -2.\n</code></pre>\n<h3>Process:</h3>\n<ul>\n<li>有点意思，既然是要 O(1) 这样的方式操作，就必须多保存一些信息，并且在每步操作的时候就得记录和更新。</li>\n<li>一开始没想出来，看到提示恍然大悟。。。</li>\n</ul>\n<h3>Answer:</h3>\n<h3>Others Answer:</h3>","frontmatter":{"title":"MinStack","timeSpent":null,"qId":null,"date":"2020-04-10","conquered":null,"wrongTime":null,"withHelp":null}}},{"node":{"fields":{"slug":"/30days-challenge/week2/backspace-str-compare/"},"html":"<h2>backspaceCompare (16 mins)</h2>\n<h3>Question：</h3>\n<h5>Description:</h5>\n<ul>\n<li>Given two strings S and T, return if they are equal when both are typed into empty text editors. # means a backspace character.</li>\n</ul>\n<h5>Note:</h5>\n<ul>\n<li>1 &#x3C;= S.length &#x3C;= 200</li>\n<li>1 &#x3C;= T.length &#x3C;= 200</li>\n<li>S and T only contain lowercase letters and '#' characters.</li>\n<li>Can you solve it in O(N) time and O(1) space?</li>\n</ul>\n<h5>Examples:</h5>\n<pre><code>Input: S = \"ab#c\", T = \"ad#c\"\nOutput: true\nExplanation: Both S and T become \"ac\".\n\nInput: S = \"ab##\", T = \"c#d#\"\nOutput: true\nExplanation: Both S and T become \"\".\n\nInput: S = \"a##c\", T = \"#a#c\"\nOutput: true\nExplanation: Both S and T become \"c\".\n\nInput: S = \"a#c\", T = \"b\"\nOutput: false\nExplanation: S becomes \"c\" while T becomes \"b\".\n</code></pre>\n<h3>Process:</h3>\n<ul>\n<li>一种想法，应该很容易实现的是 分别算出两个的值，然后对比</li>\n<li>另一个想法，算一个值，然后直接验证另一个</li>\n<li>第三种想法，同时指针运算两个字符串？</li>\n</ul>\n<h3>Answer:</h3>\n<h3>Others Answer:</h3>","frontmatter":{"title":"backspaceCompare","timeSpent":null,"qId":null,"date":"2020-04-09","conquered":null,"wrongTime":null,"withHelp":null}}},{"node":{"fields":{"slug":"/30days-challenge/week2/middle-of-the-linked-list/"},"html":"<h2>Middle of the Linked List (10 mins)</h2>\n<h3>Question：</h3>\n<h5>Description:</h5>\n<ul>\n<li>Given a non-empty, singly linked list with head node head, return a middle node of linked list.</li>\n<li>If there are two middle nodes, return the second middle node.</li>\n</ul>\n<h5>Note:</h5>\n<ul>\n<li>The number of nodes in the given list will be between 1 and 100.</li>\n</ul>\n<h5>Examples:</h5>\n<pre><code>Input: [1,2,3,4,5]\nOutput: Node 3 from this list (Serialization: [3,4,5])\nThe returned node has value 3.  (The judge's serialization of this node is [3,4,5]).\nNote that we returned a ListNode object ans, such that:\nans.val = 3, ans.next.val = 4, ans.next.next.val = 5, and ans.next.next.next = NULL.\n\nInput: [1,2,3,4,5,6]\nOutput: Node 4 from this list (Serialization: [4,5,6])\nSince the list has two middle nodes with values 3 and 4, we return the second one.\n</code></pre>\n<h3>Process:</h3>\n<ul>\n<li>mark 感觉mark一下，遍历的时候把每个序号存一下，然后到时候直接return 这个obj 就可以了 o1 的算法</li>\n</ul>\n<h3>Answer:</h3>\n<h3>Others Answer:</h3>","frontmatter":{"title":"Middle of the Linked List","timeSpent":null,"qId":null,"date":"2020-04-09","conquered":null,"wrongTime":null,"withHelp":null}}},{"node":{"fields":{"slug":"/30days-challenge/week1/counting-elements/"},"html":"<h2>countElements (8 mins)</h2>\n<h3>Question：</h3>\n<h5>Description:</h5>\n<ul>\n<li>Given an integer array arr, count element x such that x + 1 is also in arr.</li>\n<li>If there're duplicates in arr, count them seperately.</li>\n</ul>\n<h5>Note:</h5>\n<ul>\n<li>placeholder</li>\n</ul>\n<h5>Examples:</h5>\n<pre><code>Input: arr = [1,2,3]\nOutput: 2\nExplanation: 1 and 2 are counted cause 2 and 3 are in arr.\n\nInput: arr = [1,1,3,3,5,5,7,7]\nOutput: 0\nExplanation: No numbers are counted, cause there's no 2, 4, 6, or 8 in arr.\n\nInput: arr = [1,3,2,3,5,0]\nOutput: 3\nExplanation: 0, 1 and 2 are counted cause 1, 2 and 3 are in arr.\n\nInput: arr = [1,1,2,2]\nOutput: 2\nExplanation: Two 1s are counted cause 2 is in arr.\n</code></pre>\n<h3>Process:</h3>\n<ul>\n<li>有一点感觉了，看到这个题目就想到 用object 累加下，扫一遍得到所有的数据的count</li>\n<li>在扫一遍，就知道所有结果了</li>\n</ul>\n<h3>Answer:</h3>\n<h3>Others Answer:</h3>","frontmatter":{"title":"countElements","timeSpent":null,"qId":null,"date":"2020-04-08","conquered":null,"wrongTime":null,"withHelp":null}}},{"node":{"fields":{"slug":"/30days-challenge/week1/group-anagrams/"},"html":"<h2>groupAnagrams ( mins)</h2>\n<h3>Question：</h3>\n<h5>Description:</h5>\n<ul>\n<li>Given an array of strings, group anagrams together.</li>\n</ul>\n<h5>Note:</h5>\n<ul>\n<li>All inputs will be in lowercase.</li>\n<li>The order of your output does not matter.</li>\n</ul>\n<h5>Examples:</h5>\n<pre><code>Input: [\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"],\nOutput:\n[\n  [\"ate\",\"eat\",\"tea\"],\n  [\"nat\",\"tan\"],\n  [\"bat\"]\n]\n</code></pre>\n<h3>Process:</h3>\n<ul>\n<li>placeholder</li>\n</ul>\n<h3>Answer:</h3>\n<h3>Others Answer:</h3>","frontmatter":{"title":"groupAnagrams","timeSpent":null,"qId":null,"date":"2020-04-08","conquered":null,"wrongTime":null,"withHelp":null}}},{"node":{"fields":{"slug":"/30days-challenge/week1/best-time-to-buy-and-sell-stock-2/"},"html":"<h2>sellStock2 (47 mins)</h2>\n<h3>Question：</h3>\n<h5>Description:</h5>\n<ul>\n<li>Say you have an array for which the ith element is the price of a given stock on day i.</li>\n<li>Design an algorithm to find the maximum profit. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times).</li>\n</ul>\n<h5>Note:</h5>\n<ul>\n<li>You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again).</li>\n</ul>\n<h5>Examples:</h5>\n<pre><code>Input: [7,1,5,3,6,4]\nOutput: 7\nExplanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.\n             Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.\n\nInput: [1,2,3,4,5]\nOutput: 4\nExplanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.\n             Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are\n             engaging multiple transactions at the same time. You must sell before buying again.\n\nInput: [7,6,4,3,1]\nOutput: 0\nExplanation: In this case, no transaction is done, i.e. max profit = 0.\n</code></pre>\n<h3>Process:</h3>\n<ul>\n<li>一天只支持一个操作，要么买，要么买了</li>\n<li>这个题目 看下来 有点像 找最大连续的上升子区间 收尾做差，不同区间累加</li>\n</ul>\n<p>是这样的，提交的时候失败了两次，都是 判断 leftBoundary 存在的时候简单的使用了 (!xxx), (xxx) 而不是 === undefined 来判断</p>\n<h3>Answer:</h3>\n<h3>Others Answer:</h3>","frontmatter":{"title":"sellStock2","timeSpent":null,"qId":null,"date":"2020-04-07","conquered":null,"wrongTime":null,"withHelp":null}}},{"node":{"fields":{"slug":"/30days-challenge/week1/move-zeros/"},"html":"<h2>moveZeroes ( mins)</h2>\n<h3>Question：</h3>\n<h5>Description:</h5>\n<ul>\n<li>Given an array nums, write a function to move all 0's to the end of it while maintaining the relative order of the non-zero elements.</li>\n</ul>\n<h5>Note:</h5>\n<ul>\n<li>You must do this in-place without making a copy of the array.</li>\n<li>Minimize the total number of operations.</li>\n</ul>\n<h5>Examples:</h5>\n<pre><code>Input: [0,1,0,3,12]\nOutput: [1,3,12,0,0]\n</code></pre>\n<h3>Process:</h3>\n<ul>\n<li>placeholder</li>\n</ul>\n<h3>Answer:</h3>\n<h3>Others Answer:</h3>","frontmatter":{"title":"moveZeroes","timeSpent":null,"qId":null,"date":"2020-04-07","conquered":null,"wrongTime":null,"withHelp":null}}},{"node":{"fields":{"slug":"/30days-challenge/week1/maximum-subarray/"},"html":"<h2>maxSubArray ( mins)</h2>\n<h3>Question：</h3>\n<h5>Description:</h5>\n<ul>\n<li>Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.</li>\n</ul>\n<h5>Note:</h5>\n<ul>\n<li>If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle.</li>\n</ul>\n<h5>Examples:</h5>\n<pre><code>Input: [-2,1,-3,4,-1,2,1,-5,4],\nOutput: 6\nExplanation: [4,-1,2,1] has the largest sum = 6.\n</code></pre>\n<h3>Process:</h3>\n<ul>\n<li>一开始完全无从下手，暴力求解 bruta force也没有去想。。O(n ^ 3)</li>\n<li>后来做到后面有意识这道题是动态规划，还是没有去做出来</li>\n<li>后来听了个youtube老哥的视频<a href=\"https://www.youtube.com/watch?v=jcjXgmHHpds\">https://www.youtube.com/watch?v=jcjXgmHHpds</a></li>\n<li>后来恍然大悟</li>\n<li>主要还是证明自己的理解是对的，或者说 理解 为什么前后会有关联的过程</li>\n<li>可以看到解法中sum 对应的项代表，遍历到这里的时候的最大值，</li>\n<li>两种情况，一种是 前面最大值加上自己（连续下去）</li>\n<li>另一种是 就是当前的值，（重新计数）</li>\n<li>第一种情况，前面的最大值加上自己，这个也没有限制 是哪个区间段，不过总体两个走向，加上自己，或者从头再来，还是很有道理的。</li>\n<li>主要是 没有想通，为什么 一定只有两种方式</li>\n<li>\n<p>为什么  不可以什么都不做。取之前的。</p>\n<ul>\n<li>这个我理解是 为了连续 所以要这么算，具体取不取之前的，这个最后会有定论/</li>\n</ul>\n</li>\n<li>所以 针对新值，实际有三种情况，连续下去，，重投再来，索性不管，索性不管我们不考虑，在另一个唯独考虑，处于连续性只考虑两种</li>\n</ul>\n<h3>Answer:</h3>\n<h3>Others Answer:</h3>","frontmatter":{"title":"maxSubArray","timeSpent":null,"qId":null,"date":"2020-04-06","conquered":null,"wrongTime":null,"withHelp":null}}},{"node":{"fields":{"slug":"/30days-challenge/week1/happy-number/"},"html":"<h2>Happy Number (48mins)</h2>\n<h3>Question：</h3>\n<h5>Description:</h5>\n<ul>\n<li>Write an algorithm to determine if a number is \"happy\".</li>\n<li>A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy numbers.</li>\n</ul>\n<!-- ##### Note:\n* Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory? -->\n<h5>Examples:</h5>\n<pre><code>Input: 19\nOutput: true\nExplanation:\n1^2 + 9^2 = 82\n8^2 + 2^2 = 68\n6^2 + 8^2 = 100\n1^2 + 0^2 + 0^2 = 1\n</code></pre>\n<h3>Process:</h3>\n<ol>\n<li>保存计算过的部分，这个有助于减少循环的次数</li>\n<li>如何judge死循环呢？</li>\n<li><strong>这两个可能得放在一起考虑，保存的是一个数组，\n递归函数把计算过程也带上去了，如果数组中出现已经算过了，那么就证明有循环了，判定false</strong></li>\n</ol>\n<h3>Answer:</h3>\n<h3>Others Answer:</h3>","frontmatter":{"title":"Happy Number","timeSpent":null,"qId":null,"date":"2020-04-05","conquered":null,"wrongTime":null,"withHelp":null}}},{"node":{"fields":{"slug":"/30days-challenge/week1/single-number/"},"html":"<h2>Single Number</h2>\n<h3>Question：</h3>\n<h5>Description:</h5>\n<ul>\n<li>Given a non-empty array of integers, every element appears twice except for one. Find that single one.</li>\n</ul>\n<h5>Note:</h5>\n<ul>\n<li>Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?</li>\n</ul>\n<h5>Examples:</h5>\n<pre><code>Input: [2,2,1]\nOutput: 1\n\nInput: [4,1,2,1,2]\nOutput: 4\n</code></pre>\n<h3>Answer:</h3>\n<h3>Others Answer:</h3>","frontmatter":{"title":"Single Number","timeSpent":null,"qId":null,"date":"2020-04-04","conquered":null,"wrongTime":null,"withHelp":null}}}]}},"pageContext":{}}}